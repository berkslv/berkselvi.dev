<!doctype html><html lang=tr><head><title>Event-Driven Architecture: Mikroservis mimarisinde baÅŸka servislerin verilerine mi ihtiyacÄ±nÄ±z var :: Berk Selvi | Software Developer</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Mikroservis mimarisinde, servisler arasÄ±ndaki veri baÄŸÄ±mlÄ±lÄ±ÄŸÄ± senkron veya asenkron iletiÅŸimle yÃ¶netilebilir. Senkron iletiÅŸim, sÄ±kÄ± servis baÄŸlantÄ±sÄ± nedeniyle Ã¶lÃ§eklenebilirlik ve eriÅŸilebilirlik sorunlarÄ±na neden olabilirken, asenkron iletiÅŸim baÄŸÄ±mlÄ±lÄ±ÄŸÄ± azaltarak servislerin baÄŸÄ±msÄ±z olarak Ã§alÄ±ÅŸmasÄ±na olanak tanÄ±r. DoÄŸru yÃ¶ntemi seÃ§mek belirli senaryoya baÄŸlÄ±dÄ±r, ancak asenkron iletiÅŸim genellikle daha Ã¶lÃ§eklenebilir ve eriÅŸilebilir Ã§Ã¶zÃ¼mler sunar."><meta name=keywords content="microservices,event,service to service comminication,synchronous communication,asynchronous communication"><meta name=robots content="noodp"><link rel=canonical href=https://berkselvi.dev/tr/posts/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/><link rel=stylesheet href=https://berkselvi.dev/assets/style.css><link rel=stylesheet href=https://berkselvi.dev/assets/green.css><link rel=canonical href=https://berkselvi.dev/tr/posts/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/><link rel=apple-touch-icon sizes=57x57 href=/icon/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/icon/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/icon/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/icon/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/icon/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/icon/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/icon/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/icon/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/icon/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/icon/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/icon/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/icon/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/icon/favicon-16x16.png><link rel=manifest href=/icon/manifest.json><meta name=msapplication-TileColor content="#1D1E28"><meta name=msapplication-TileImage content="/icon/ms-icon-144x144.png"><meta name=theme-color content="#1D1E28"><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="berkslv"><meta property="og:locale" content="tr"><meta property="og:type" content="article"><meta property="og:title" content="Event-Driven Architecture: Mikroservis mimarisinde baÅŸka servislerin verilerine mi ihtiyacÄ±nÄ±z var"><meta property="og:description" content="Mikroservis mimarisinde, servisler arasÄ±ndaki veri baÄŸÄ±mlÄ±lÄ±ÄŸÄ± senkron veya asenkron iletiÅŸimle yÃ¶netilebilir. Senkron iletiÅŸim, sÄ±kÄ± servis baÄŸlantÄ±sÄ± nedeniyle Ã¶lÃ§eklenebilirlik ve eriÅŸilebilirlik sorunlarÄ±na neden olabilirken, asenkron iletiÅŸim baÄŸÄ±mlÄ±lÄ±ÄŸÄ± azaltarak servislerin baÄŸÄ±msÄ±z olarak Ã§alÄ±ÅŸmasÄ±na olanak tanÄ±r. DoÄŸru yÃ¶ntemi seÃ§mek belirli senaryoya baÄŸlÄ±dÄ±r, ancak asenkron iletiÅŸim genellikle daha Ã¶lÃ§eklenebilir ve eriÅŸilebilir Ã§Ã¶zÃ¼mler sunar."><meta property="og:url" content="https://berkselvi.dev/tr/posts/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/"><meta property="og:site_name" content="Berk Selvi | Software Developer"><meta property="og:image" content="https://berkselvi.dev/img/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/cover.jpg"><meta property="twitter:image" content="https://berkselvi.dev/img/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/cover.jpg"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2024-09-07 00:00:00 +0300 +0300"><script async src="https://www.googletagmanager.com/gtag/js?id=G-W0L24EMSQ5"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W0L24EMSQ5")</script><link href=https://berkselvi.dev/css/custom.css rel=stylesheet></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=menu-trigger><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu"><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/></svg></div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/tr>ana sayfa</a></li><div class=spacer></div><ul class=language-selector><ul class=language-selector-current><li>tÃ¼rkÃ§e â–¾</li></ul><ul class="language-selector__more hidden"><li><a href=https://berkselvi.dev/>english</a></li><li><a href=https://berkselvi.dev/tr/>tÃ¼rkÃ§e</a></li></ul></ul></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/tr>ana sayfa</a></li><hr><li><a href=https://berkselvi.dev/>english</a></li><li><a href=https://berkselvi.dev/tr/>tÃ¼rkÃ§e</a></li></ul></nav></header><div class=content><div class=post><h4>Translations;</h4><a href=/posts/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/>Event-Driven Architecture: Do you need other serviceâ€™s data in microservice architecture</a><h1 class=post-title><a href=https://berkselvi.dev/tr/posts/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/>Event-Driven Architecture: Mikroservis mimarisinde baÅŸka servislerin verilerine mi ihtiyacÄ±nÄ±z var</a></h1><div class=post-meta><span class=post-date>7 EylÃ¼l 2024
</span><span class=post-author>:: Berk Selvi</span>
<span class=post-reading-time>:: 7 min read (1466 words)</span></div><div class=post-content><div><p>Microservice mimarisinde geliÅŸtirilen uygulamalarda domainler genellikle birbirlerinden sÄ±kÄ± bir ÅŸekilde ayrÄ±lmaya Ã§alÄ±ÅŸÄ±lÄ±yor, inceleyeceÄŸimiz Ã¶rnekte Ã¼rÃ¼n ile ilgili tÃ¼m logic ve data product servisinde yer alÄ±rken, bu Ã¼rÃ¼n ile sipariÅŸ oluÅŸturabilecek satÄ±ÅŸ danÄ±ÅŸmanlarÄ±nÄ± yÃ¶neten organization serviside kendi logic ve datasÄ±nÄ± barÄ±ndÄ±rÄ±yor.</p><p>Ancak organization servisinde satÄ±ÅŸ danÄ±ÅŸmanÄ± oluÅŸturmak iÃ§in yapacaÄŸÄ±mÄ±z <code>createUnit()</code> isteÄŸi validasyon sebepleri iÃ§in product servisinin verisine ihtiyaÃ§ duyacaktÄ±r. Var olmayan bir Ã¼rÃ¼n iÃ§in oluÅŸturma izni unitâ€™e verilmemeli deÄŸil mi? Bu durumda organization servisi kendi domainâ€™inde yer almayan ve kendi sorumluluÄŸunda olmayan product servisinin verisine ihtiyaÃ§ duyacak.</p><p>Bu veriye senkron veya asenkron olarak eriÅŸebiliriz. ilk olarak senkron olarak eriÅŸecek ve yaÅŸayacaÄŸÄ±mÄ±z sorunlarÄ± ele aldÄ±ktan sonra, asenkron methodu kullanÄ±p yaÅŸayabileceÄŸimiz sorunlarÄ± ele alacaÄŸÄ±z, hadi baÅŸlayalÄ±m.</p><h2 id=synchronous-communication>Synchronous communication<a href=#synchronous-communication class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Organization servisimize rest ile gÃ¶ndereceÄŸimiz istek ile, createUnit() methodunu tetikletecek ve unit oluÅŸturacaÄŸÄ±z, ancak bu servis product verisine validasyon sebebiyle iÃ§in ihtiyaÃ§ duyacaÄŸÄ± iÃ§in bu veriyi senkron olarak, HTTP REST yardÄ±mÄ±yla yapacaÄŸÄ± <code>getProduct()</code> isteÄŸi ile getirmesi gerekecektir.</p><p>runtime sÄ±rasÄ±nda, createUnit methodunun iÅŸlenebilmesi iÃ§in organization servisine ek olarak product servisininde ayakta ve eriÅŸilebilir olmasÄ±, aradaki network baÄŸlantÄ±sÄ±nda bir sorun olmamasÄ± gerekiyor. EÄŸer product servisi Ã§alÄ±ÅŸmÄ±yorsa, organization serviside Ã§alÄ±ÅŸmayacaktÄ±r. Her iki serviste ayakta ve eriÅŸilebilir olduÄŸu durumlarda ise product servisi yavaÅŸ Ã§alÄ±ÅŸÄ±yorsa, senkron yapacaÄŸÄ±mÄ±z istek akÄ±ÅŸÄ± bloklayacaÄŸÄ± iÃ§in, organization serviside yavaÅŸ Ã§alÄ±ÅŸacaktÄ±r. Bu sorunu aÅŸmak iÃ§in organization servisinin yoÄŸun istek aldÄ±ÄŸÄ± durumlarda scale edilecektir. Ancak runtime baÄŸÄ±mlÄ±lÄ±ÄŸÄ± bulunan product servisininde organizationdan gelecek bol miktarda isteÄŸi karÅŸÄ±layabilmek iÃ§in aynÄ± ÅŸekilde scale etmemiz gerekecektir. Bu pratiÄŸi tÃ¼m servislere uyguladÄ±ÄŸÄ±mÄ±z senaryoda, tÃ¼m servislerin beraber scale edilmesi gerekecektir. Bu sebeple Organization servisi, Product servisine son derece baÄŸÄ±mlÄ± olup, yaÅŸamlarÄ±na kendi baÅŸlarÄ±na deÄŸil, beraber devam etmek zorunda kalacaklardÄ±r. EÄŸer microservice mimarimizdeki tÃ¼m servislerimiz birbirlerine bu ÅŸekilde baÄŸÄ±mlÄ± olursa tek bir servisin eriÅŸilemez olmasÄ± diÄŸer tÃ¼m servislerin eriÅŸilemez olmasÄ±na yol aÃ§abilir.</p><p>design time sÄ±rasÄ±nda ise product servisinin getProduct APIâ€™Ä±nda yapÄ±lacak olan bir geliÅŸtirme sonrasÄ± Organization servisinin geliÅŸtirici takÄ±mÄ±da aynÄ± deÄŸiÅŸikliÄŸi kendi Product HTTP Client entegrasyonlarÄ±nda yapmalarÄ± gerekecektir. Bu deÄŸiÅŸiklik bÃ¼yÃ¼k olasÄ±lÄ±kla organization servisinin iÅŸ akÄ±ÅŸlarÄ±ndada kod deÄŸiÅŸikliÄŸe yol aÃ§acaktÄ±r.</p><p>SonuÃ§ olarak hem runtimeâ€™da hemde design timeâ€™da coupling ortaya Ã§Ä±kacaÄŸÄ± iÃ§in iki servis birbirine gÃ¶bekten baÄŸlÄ± olacaktÄ±r, Jonathan Towerâ€™Ä±n tabiriyle <a href="https://www.youtube.com/watch?v=p2GlRToY5HI&amp;t=1203s">distributed monolith</a> geliÅŸtirmiÅŸ olacaÄŸÄ±z. Bir servisimizde yapÄ±lacak olan deÄŸiÅŸiklik, diÄŸer serviside direk olarak etkileyeceÄŸinden Ã¶tÃ¼rÃ¼, sÃ¼rekli deÄŸiÅŸen iÅŸ gereksinimlerine hÄ±zlÄ±ca cevap veremeyeceÄŸiz. Product servisinin getProduct() methodunda yapÄ±lan herhangi bir geliÅŸtirmeye istinaden, bu ucu kullanan diÄŸer servislerinde aynÄ± geliÅŸtirmeyi kendi servislerinde yapmasÄ± gerekecektir. GeliÅŸtirmeyi bir ÅŸekilde tamamladÄ±ktan sonrada son kullanÄ±cÄ±larÄ±n uygulamamÄ±zÄ± kullanabilmesi iÃ§in senkron olarak birbirlerine baÄŸlÄ± olan tÃ¼m servislerin eriÅŸilebilir olmasÄ± gerekecektir.</p><img src=/img/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/synchronous-communication.png alt="Synchronous communication" loading=lazy><p class=image-sub-title>Synchronous communication</p><p>MÃ¼ÅŸterimize bir SLA garantisi vermek istediÄŸimiz senaryoda, iyimser olarak Product ve Organization servislerimiz iÃ§in %99.5 uptime garantisi verecek olursak yÄ±llÄ±k 43 saat downtime yaÅŸanabileceÄŸini kabul ediyoruz. product ve organization servislerinin runtimeâ€™da baÄŸÄ±mlÄ± olacaÄŸÄ± senaryoda $0.995 * 0,995 = 0.990$ hesabÄ±yla senkron iletiÅŸimle beraber Ã§alÄ±ÅŸan servislerimiz ile yaÅŸanan baÄŸÄ±mlÄ±lÄ±k sonucunda, her bir servisimiz iki kat daha kÃ¶tÃ¼ uptime garanti ederek, yÄ±llÄ±k 87 saat downtime yaÅŸayabileceklerini gÃ¶rÃ¼yoruz.</p><table><thead><tr><th></th><th>Product</th><th>Organization</th><th>Product & Organization</th></tr></thead><tbody><tr><td>Uptime percentege</td><td>99.5</td><td>99.5</td><td>99.0</td></tr><tr><td>Month</td><td>716</td><td>716</td><td>712</td></tr><tr><td>Downtime in month</td><td>4</td><td>4</td><td>7</td></tr><tr><td>Year</td><td>8716</td><td>8716</td><td>8672</td></tr><tr><td>Downtime in year</td><td>43</td><td>43</td><td>87</td></tr></tbody></table><p>Peki baÅŸÄ±mÄ±zÄ± bu kadar aÄŸrÄ±tabileceÄŸini Ã¶n gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z bu yÃ¶ntemden nasÄ±l kaÃ§Ä±nacaÄŸÄ±z? Servisler arasÄ± iletiÅŸimdeki diÄŸer Ã§Ã¶zÃ¼m Ã¶nerimize bir bakalÄ±m.</p><h2 id=asynchronous-communication>Asynchronous communication<a href=#asynchronous-communication class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Senkron iletiÅŸim, servisler arasÄ± baÄŸÄ±mlÄ±lÄ±ÄŸÄ± mÃ¼mkÃ¼n olan her yÃ¶nde arttÄ±rdÄ±ÄŸÄ± iÃ§in bu seÃ§eneÄŸi tercih etmek istemezsek, diÄŸer seÃ§eneÄŸimiz olan asenkron iletiÅŸimle devam edebiliriz. Asenkron yÃ¶ntemle oklarÄ± tersine Ã§evirerek Product servisinin Product tablosunda bir gÃ¼ncelleme yaÅŸanmasÄ± durumunda ProductCreatedEvent isminde bir domain event publish ediyoruz. Bu eventi dinleyen tÃ¼m servisler, kendi veritabanlarÄ±nda tuttuklarÄ± products tablolarÄ±nÄ± gÃ¼ncelliyorlar.</p><p>Organization servisi product verisine ihtiyaÃ§ duyduÄŸunda kendi veritabanÄ±nda yer alan products tablosundan okuma yapacaktÄ±r. Bu tablo organizationâ€™Ä±n iÅŸ akÄ±ÅŸlarÄ±ndan etkilenmeden, sadece okuma yapÄ±lacaktÄ±r. Bu ÅŸekilde createUnit() methodumuzda ihtiyacÄ±mÄ±z olacak Ã¼rÃ¼n bilgisini sorgulamak iÃ§in unit verisini kaydedeceÄŸimiz aynÄ± veritabanÄ±ndan okuma yaparak ilgili veriye ulaÅŸmÄ±ÅŸ oluruz.</p><img src=/img/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/asynchronous-communication.png alt="Asynchronous communication" loading=lazy><p class=image-sub-title>Asynchronous communication</p><p>Bu yÃ¶ntemle createUnit() akÄ±ÅŸÄ±mÄ±zda product verisine organizationâ€™Ä±n kendi veritabanÄ±ndan eriÅŸerek, Product servisimize runtime sÄ±rasÄ±ndaki baÄŸÄ±mlÄ±lÄ±ÄŸÄ±mÄ±zÄ± ortadan kaldÄ±rÄ±yoruz.</p><p>Bu sayede, run time sÄ±rasÄ±ndaki baÄŸÄ±mlÄ±lÄ±k ortadan kalkÄ±yor, Ã§Ã¼nkÃ¼ product servisinin verdiÄŸi getProduct() ucunu senkron bir ÅŸekilde sorgulamayÄ± bÄ±raktÄ±k. design time sÄ±rasÄ±ndada geliÅŸtirme yaparken yaÅŸadÄ±ÄŸÄ±mÄ±z baÄŸÄ±mlÄ±lÄ±kta ortadan kalkmÄ±ÅŸ oluyor. Ã‡Ã¼nkÃ¼ Product servisinin getProduct() methodunda yaptÄ±ÄŸÄ±mÄ±z bir deÄŸiÅŸiklik sonrasÄ±nda Organization servisine sahip olan takÄ±mÄ±n kendi servislerinde bir deÄŸiÅŸiklik yapmasÄ± gerekmiyor.</p><p>Design time sÄ±rasÄ±ndada asenkron bir baÄŸÄ±mlÄ±lÄ±ÄŸÄ±mÄ±z var, sadece ihtiyacÄ±mÄ±z olduÄŸu durumlarda ilgili deÄŸiÅŸiklikleri yapmamÄ±z gerekiyor. EÄŸer Product servisinin product domain modelinde bir deÄŸiÅŸiklik yapÄ±larak yeni bir kolon eklenirse, bu kolon direk olarak eventâ€™e yeni bir field olarak eklenebilir. EÄŸer product tablosunda bir kolon silindiyse, bu kolon, event tipinde silinmeden default deÄŸerleri ile gÃ¶nderilmeye baÅŸlanÄ±p, obsolete olarakta iÅŸaretlenebilir. Bu eklenip Ã§Ä±kartÄ±lan kolonlara diÄŸer servisler diledikleri gibi cevap verebilir veya hiÃ§ bir deÄŸiÅŸiklik yapmadan kendi hayatlarÄ±na devam edebilirler.</p><p>Publish edilen eventin, kimler tarafÄ±ndan iÅŸlendiÄŸi publish eden taraf olan Product servisini ilgilendirmez. ArtÄ±k bu veriye ihtiyacÄ± olan herkes bu eventi consume edip, kendi veritabanlarÄ±nda product verisinin bir kopyasÄ±nÄ± tutarak, Product servisiyle senkron bir iletiÅŸime geÃ§meden kendi iÅŸlerini kendi baÅŸlarÄ±na halledebiliyorlar. Bu ÅŸekilde daha scale edilebilir ve daha eriÅŸilebilir uygulamalar ortaya Ã§Ä±karmÄ±ÅŸ oluyoruz, Ã§Ã¼nkÃ¼ artÄ±k uygulamalarÄ±mÄ±zÄ±n farklÄ± bir servise baÄŸÄ±mlÄ±lÄ±ÄŸÄ± bulunmadan kendi baÅŸlarÄ±na hareket edilebiliyorlar.</p><p>EÄŸer tablolarÄ±mÄ±zÄ±n domain bazÄ±nda karÄ±ÅŸacaÄŸÄ±nÄ± dÃ¼ÅŸÃ¼nÃ¼yorsak farklÄ± domainlerden gelecek olan tablolarÄ± aÅŸaÄŸÄ±daki Ã¶rnekteki gibi farklÄ± bir veritabanÄ± ÅŸemasÄ±nda tutabiliriz.</p><img src=/img/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/asynchronous-communication-2.png alt="Asynchronous communication" loading=lazy><p class=image-sub-title>Asynchronous communication 2</p><h2 id=eventual-consistency>Eventual consistency<a href=#eventual-consistency class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Bu yÃ¶ntemin karÅŸÄ±mÄ±za Ã§Ä±kartacaÄŸÄ± en bÃ¼yÃ¼k sorun, eventual consistency yaratacak olmasÄ±dÄ±r. Product servisine eklenen bir Ã¼rÃ¼nÃ¼n, organization servisindeki ilgili tabloya yansÄ±masÄ± aynÄ± t anÄ±nda deÄŸil, aradaki message brokerâ€™Ä±n eriÅŸilebilirlik durumuna gÃ¶re, birkaÃ§ milisaniye veya saniye gecikme ile yaÅŸanacaktÄ±r.</p><p>Bu durumu CAP teorisiylede aÃ§Ä±klayabiliriz. CAP teorisinin 3 bacaÄŸÄ±ndan biri olan Partition tolarence bacaÄŸÄ±nÄ± sabit tutarsak, Consistency ve Availability bacaklarÄ±ndan birisi artarken diÄŸeri azalacaktÄ±r. DolayÄ±sÄ±yla bu Ã¼Ã§ seÃ§eneÄŸi aynÄ± anda saÄŸlayamayacaÄŸÄ±z. Buradada Ã§alÄ±ÅŸtÄ±ÄŸÄ±mÄ±z iÅŸ akÄ±ÅŸÄ±na gÃ¶re karar vermemiz gerekiyor.</p><p>Ã–rneÄŸin bir eticaret sisteminde sepete ekleme Ã¶zelliÄŸinin highly avaliable olmasÄ± gerekebilir, Ã§Ã¼nkÃ¼ sepete ekleme Ã¶zelliÄŸi Ã§alÄ±ÅŸmÄ±yorsa, lÃ¼tfen daha sonra tekrar deneyin gibi bir hata alÄ±yorsak, o sitede deÄŸil rakip sitede alÄ±ÅŸveriÅŸe devam etmemiz olasÄ±dÄ±r. Ancak sepete devam ettiÄŸimizde istediÄŸimiz Ã¼rÃ¼nden 1 deÄŸil 2 adet gÃ¶rÃ¼rsek ilgili dÃ¼zeltmemizi yapÄ±p Ã¶demeye devam edebiliriz.</p><p>Fakat aynÄ± durumu otel rezervasyonlarÄ±nda uygulayamayabiliriz. Sepet Ã¶rneÄŸimizin tersine consistency muhtemelen daha Ã¶nemli olacaktÄ±r. AynÄ± odayÄ± birden Ã§ok kiÅŸiye kiralamak yerine, lÃ¼tfen daha sonra tekrar deneyin gibi bir hata dÃ¶nmek Ã§ok daha mantÄ±klÄ± olabilir.</p><p>SonuÃ§ olarak senkron iletiÅŸimin uygun olduÄŸu immediate consistency isteyen akÄ±ÅŸlar iÃ§in senkron iletiÅŸim, high avalability ihtiyacÄ± olan akÄ±ÅŸlar iÃ§in ise asenkron iletiÅŸimden faydalanabiliriz. Burada kÃ¼Ã§Ã¼k bir yorum olarak microservice mimarisindeki akÄ±ÅŸlarda genellikle high avalability tercih edilmesi gerekiyor, Ã§Ã¼nkÃ¼ diÄŸer senkron iletiÅŸim yÃ¶ntemiyle tÃ¼m servislerimiz gÃ¶bekten birbirlerine baÄŸÄ±mlÄ± olacaklardÄ±r.</p><img src=/img/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/high-avalability-vs-immidiate-consistency.png alt="High avalability vs Immidiate consistency" loading=lazy><p class=image-sub-title>High avalability vs Immidiate consistency</p><h2 id=edge-cases-in-asynchronous-communication>Edge cases in asynchronous communication<a href=#edge-cases-in-asynchronous-communication class=hanchor arialabel=Anchor>&#8983;</a></h2><p>EÄŸer servisleriniz arasÄ±ndaki iletiÅŸimde, event driven architecture ile ilerlemeye karar verdiyseniz sistemdeki veri tutarlÄ±lÄ±ÄŸÄ±nÄ± saÄŸlamak iÃ§inde bir ÅŸeyler yapmanÄ±z gerekecektir. Bir servisimize create isteÄŸi gelir ve CreatedEvent publish edersek, ilk Ã¶nce veritabanÄ±nÄ± gÃ¼ncelleyip, sornasÄ±nda event publish ettiÄŸimiz durumda, eÄŸer veritabanÄ±nda yÃ¼rÃ¼ttÃ¼ÄŸÃ¼mÃ¼z transaction hatayla sonuÃ§lanÄ±r, ve bunu takip etmeden eventi publish edersek, veya veritabanÄ±nda yÃ¼rÃ¼ttÃ¼ÄŸÃ¼mÃ¼z transaction baÅŸarÄ±yla sonuÃ§lanÄ±r, ancak sonrasÄ±nda event busâ€™a eriÅŸilemezse, uygulamalarÄ±mÄ±zda daÄŸÄ±tÄ±k olarak duran veri, insonsistent stateâ€™e dÃ¼ÅŸebilir. Bu durumun Ã¶nÃ¼ne geÃ§mek iÃ§in product servisi kendi veritabanÄ±ndaki product verisini gÃ¼ncellerken aynÄ± zamanda aynÄ± veritabanÄ±nda yer alan outbox tablosunada ilgili eventi ekledikten sonra, farklÄ± bir thread bu tabloyu devamlÄ± olarak tarayarak yeni gelen eventleri publish eder. VeritabanÄ±na yaptÄ±ÄŸÄ±mÄ±z kayÄ±t atomic olarak iÅŸleneceÄŸi iÃ§in product verisi oluÅŸturulurken event verisininde outbox tablosunda oluÅŸturulacaÄŸÄ± garanti edilir. Fakat birden Ã§ok instance olarak Ã§alÄ±ÅŸan bir uygulamada bir eventin aynÄ± outbox tablosundan 2 defa okuyup, 2 defa publish etmesi gibi durumlarla karÅŸÄ±laÅŸÄ±labilir. Bu durumda zaten idempotency sorununa Ã§Ä±kÄ±yor.</p><p>Bir metodun bir defa Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda alÄ±nan sonuÃ§ ile birden fazla kez Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda alÄ±nan sonuÃ§ aynÄ± ise bu bir idempotent metottur. Bir eventin, farklÄ± sebeplerden Ã¶tÃ¼rÃ¼, birden Ã§ok kez iÅŸlenip sistemdeki veri tutarlÄ±lÄ±ÄŸÄ±nÄ± bozulmasÄ±nÄ± Ã¶nlemek iÃ§in, eventlerin benzersiz message id deÄŸerlerini consume edildikten sonra veritabanÄ±na kaydedip, yeni bir event consume edileceÄŸi zaman, message id deÄŸeri veritabanÄ±nda yoksa iÅŸleme devam etmemiz gerekecektir. Chris Richardson (microservices.io) bu konuya Pattern: Idempotent Consumer isimli yazÄ±sÄ±ndada deÄŸiniyor.</p><img src=/img/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/without-outbox-idempotency.png alt="Without Outbox & Idempotency" loading=lazy><p class=image-sub-title>Without Outbox & Idempotency</p><img src=/img/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/outbox-idempotency.png alt="Outbox & Idempotency" loading=lazy><p class=image-sub-title>Outbox & Idempotency</p><p>SonuÃ§ olarak Computer Science alanÄ±ndaki Ã§oÄŸu problemle sunulan Ã§Ã¶zÃ¼m Ã¶nerilerinde olduÄŸu gibi elimizde bir silver bullet bulunmuyor. Her iki yÃ¶nteminde avantajlarÄ± ve dezavantajlarÄ±nÄ± kapsamlÄ± bir ÅŸekilde, Ã§alÄ±ÅŸtÄ±ÄŸÄ±mÄ±z domainâ€™inde aklÄ±mÄ±zda bulundurup deÄŸerlendirdikten sonra dilediÄŸimiz yÃ¶ntemle devam edebiliriz. Ancak benim Ã¶nerim, servisler arasÄ±ndaki baÄŸÄ±mlÄ±lÄ±ÄŸÄ± mÃ¼mkÃ¼n olduÄŸu durumlarda asenkron iletiÅŸim kullanarak ortadan kaldÄ±rmak olacaktÄ±r.</p><p>Asenkron ve senkron veri iletiÅŸimiyle Ã§alÄ±ÅŸÄ±rken yaÅŸanbilecek durumlarÄ± simule etmek iÃ§in geliÅŸtirdiÄŸim .NET projesine aÅŸaÄŸÄ±daki github reposundan ulaÅŸabilirsiniz. Ã–rnekte outbox yapÄ±sÄ± iÃ§in MassTransit tarafÄ±ndan saÄŸlanan altyapÄ± kullanÄ±larak bu Ã¶zellik iÃ§in Ã¶zel bir geliÅŸtirme yapÄ±lmamÄ±ÅŸtÄ±r.</p><p><a href=https://github.com/berkslv/lecture-fetch-other-service-data-with-event-driven-architecture>GitHub - berkslv/lecture-fetch-other-service-data-with-event-driven-architecture</a></p><h2 id=resources>Resources<a href=#resources class=hanchor arialabel=Anchor>&#8983;</a></h2><p><a href="https://www.youtube.com/watch?v=p2GlRToY5HI&amp;t=1203s">Donâ€™t Build a Distributed Monolith - Jonathan &ldquo;J.&rdquo; Tower - NDC London 2023</a></p><p><a href="https://www.youtube.com/watch?v=STKCRSUsyP0">The Many Meanings of Event-Driven Architecture â€¢ Martin Fowler â€¢ GOTO 2017</a></p><p><a href="https://www.youtube.com/watch?v=AEbJgpamZ4w&amp;t=898s">Solving distributed data problems in a microservice architecture | Microservices.io</a></p><p><a href="https://www.youtube.com/watch?v=rZxIzrjvSGg&amp;t=716s">You Keep Using That Word â€¢ Sam Newman â€¢ GOTO 2023</a></p><p><a href=https://microservices.io/patterns/communication-style/idempotent-consumer.html>Microservices Pattern: Pattern: Idempotent Consumer</a></p><p><a href=https://www.reactivemanifesto.org/en>The Reactive Manifesto</a></p><hr><h2 id=sonuÃ§>SonuÃ§<a href=#sonuÃ§ class=hanchor arialabel=Anchor>&#8983;</a></h2><p>OkuduÄŸunuz iÃ§in teÅŸekkÃ¼rler! ğŸ‰ YazÄ±lÄ±m geliÅŸtirme alanÄ±ndaki araÅŸtÄ±rmalarÄ±mÄ± kaÃ§Ä±rmamak iÃ§in <a href=https://x.com/berkslv>@berkslv</a> adresinden takipte kalabilirsiniz.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://berkselvi.dev/tr/posts/realtime-communication-with-signalr-a-deep-dive/><span class=button__icon>â†</span>
<span class=button__text>SignalR ile GerÃ§ek ZamanlÄ± Ä°letiÅŸim: Derinlemesine Ä°nceleme</span>
</a></span><span class="button next"><a href=https://berkselvi.dev/tr/posts/correlationid-tracing-net-microservices-with-http-and-rabbitmq/><span class=button__text>HTTP ve MassTransit ile .NET Mikroservislerinde CorrelationId Takibi</span>
<span class=button__icon>â†’</span></a></span></div></div><script src=https://utteranc.es/client.js repo=berkslv/berkselvi.dev issue-term=title theme=dark-blue crossorigin=anonymous async></script></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Made by Berk Selvi.<br>Bu websitesi <a href=https://github.com/berkslv/berkselvi.dev target=_blank>open source</a> olarak yayÄ±nlanmÄ±ÅŸtÄ±r.</span></div></div></footer><script src=https://berkselvi.dev/assets/main.js></script><script src=https://berkselvi.dev/assets/prism.js></script><script src=https://berkselvi.dev/assets/languageSelector.js></script></div></body></html>