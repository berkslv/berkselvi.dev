<!doctype html><html lang=tr><head><title>SignalR ile Gerçek Zamanlı İletişim: Derinlemesine İnceleme :: Berk Selvi | Software Developer</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Gerçek zamanlı iletişimin gücünü SignalR ile keşfedin! Bu blog yazısında, SignalR’ın WebSockets, Server-Sent Events ve Long Polling gibi karmaşık protokolleri soyutlayarak .NET uygulamalarınıza canlı özellikler eklemeyi nasıl kolaylaştırdığını öğrenin. SignalR'ı projenize kurmaktan, belirli kullanıcıları hedefleme ve Redis ile ölçeklendirme gibi ileri düzey özelliklere kadar her şeyi bu rehberde bulabilirsiniz. SignalR dünyasına adım atmaya hazır mısınız?"><meta name=keywords content="signalr,websocket,.NET,long polling"><meta name=robots content="noodp"><link rel=canonical href=https://berkselvi.dev/tr/posts/realtime-communication-with-signalr-a-deep-dive/><link rel=stylesheet href=https://berkselvi.dev/assets/style.css><link rel=stylesheet href=https://berkselvi.dev/assets/green.css><link rel=canonical href=https://berkselvi.dev/tr/posts/realtime-communication-with-signalr-a-deep-dive/><link rel=apple-touch-icon sizes=57x57 href=/icon/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/icon/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/icon/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/icon/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/icon/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/icon/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/icon/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/icon/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/icon/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/icon/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/icon/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/icon/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/icon/favicon-16x16.png><link rel=manifest href=/icon/manifest.json><meta name=msapplication-TileColor content="#1D1E28"><meta name=msapplication-TileImage content="/icon/ms-icon-144x144.png"><meta name=theme-color content="#1D1E28"><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="berkslv"><meta property="og:locale" content="tr"><meta property="og:type" content="article"><meta property="og:title" content="SignalR ile Gerçek Zamanlı İletişim: Derinlemesine İnceleme"><meta property="og:description" content="Gerçek zamanlı iletişimin gücünü SignalR ile keşfedin! Bu blog yazısında, SignalR’ın WebSockets, Server-Sent Events ve Long Polling gibi karmaşık protokolleri soyutlayarak .NET uygulamalarınıza canlı özellikler eklemeyi nasıl kolaylaştırdığını öğrenin. SignalR'ı projenize kurmaktan, belirli kullanıcıları hedefleme ve Redis ile ölçeklendirme gibi ileri düzey özelliklere kadar her şeyi bu rehberde bulabilirsiniz. SignalR dünyasına adım atmaya hazır mısınız?"><meta property="og:url" content="https://berkselvi.dev/tr/posts/realtime-communication-with-signalr-a-deep-dive/"><meta property="og:site_name" content="Berk Selvi | Software Developer"><meta property="og:image" content="https://berkselvi.dev/img/realtime-communication-with-signalr-a-deep-dive/cover.webp"><meta property="twitter:image" content="https://berkselvi.dev/img/realtime-communication-with-signalr-a-deep-dive/cover.webp"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2024-11-29 00:00:00 +0300 +0300"><script async src="https://www.googletagmanager.com/gtag/js?id=G-W0L24EMSQ5"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W0L24EMSQ5")</script><link href=https://berkselvi.dev/css/custom.css rel=stylesheet></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=menu-trigger><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu"><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/></svg></div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/tr>ana sayfa</a></li><div class=spacer></div><ul class=language-selector><ul class=language-selector-current><li>türkçe ▾</li></ul><ul class="language-selector__more hidden"><li><a href=https://berkselvi.dev/>english</a></li><li><a href=https://berkselvi.dev/tr/>türkçe</a></li></ul></ul></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/tr>ana sayfa</a></li><hr><li><a href=https://berkselvi.dev/>english</a></li><li><a href=https://berkselvi.dev/tr/>türkçe</a></li></ul></nav></header><div class=content><div class=post><h4>Translations;</h4><a href=/posts/realtime-communication-with-signalr-a-deep-dive/>Real-Time Communication with SignalR: A Deep Dive</a><h1 class=post-title><a href=https://berkselvi.dev/tr/posts/realtime-communication-with-signalr-a-deep-dive/>SignalR ile Gerçek Zamanlı İletişim: Derinlemesine İnceleme</a></h1><div class=post-meta><span class=post-date>29 Kasım 2024
</span><span class=post-author>:: Berk Selvi</span>
<span class=post-reading-time>:: 7 min read (1479 words)</span></div><div class=post-content><div><p>Günümüz dünyasında verilerin hızla hareket ettiği bir ortamda, modern uygulamaların kullanıcılarına sorunsuz deneyimler sunabilmesi için gerçek zamanlı iletişim bir zorunluluk haline gelmiştir. SignalR, .NET uygulamaları için gerçek zamanlı iletişim özelliklerini kolayca hayata geçirmenize yardımcı olan temel bir kütüphanedir. SignalR kullanırken tüm iletişim ve network gereksinimleri kütüphane tarafından soyutlanır; sadece bir RPC çağrısı yapar gibi yöntem çağrısında bulunmanız yeterlidir. SignalR sayesinde canlı panolar, sohbet uygulamaları veya web uygulamalarında sıkça ihtiyaç duyulan basit bildirim özelliklerini kolayca oluşturabilirsiniz. Haydi başlayalım.</p><h2 id=neden-signalr>Neden SignalR?<a href=#neden-signalr class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Geleneksel istemci-sunucu iletişim modelleri, yüksek etkileşim ihtiyaçları için daha az verimli ve sınırlı olan istek-cevap modeline dayanır ve veriye ihtiyaç duyulduğunda istemcinin bir istek göndermesini gerektirir. SignalR, istemci ile sunucu arasındaki aynı bağlantıyı sürekli açık tutarak bu zorlukları ortadan kaldırmak için tasarlanmıştır.</p><h3 id=signalrın-temel-avantajları>SignalR’ın Temel Avantajları:<a href=#signalrın-temel-avantajları class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li><strong>Gerçek Zamanlı İletişim:</strong> İstemciler, yeni bir istek göndermeye gerek kalmadan anında güncellemeleri alır.</li><li><strong>Çapraz Platform Desteği:</strong> SignalR, platform ve tarayıcıdan bağımsızdır.</li><li><strong>Karmaşık Protokollerin Soyutlanması:</strong> SignalR, WebSocket, Server-Sent Events ve Long Polling protokollerini kullanma yeteneğine sahiptir. Bu, istemci ve sunucu arasında daha verimli bir ilişki sağlar ve en uygun protokolün seçilmesine olanak tanır. WebSocket protokolü istemci tarafından desteklenmiyorsa, SignalR kendi iç algoritmasına göre diğer yöntemleri seçerek kullanır.</li><li><strong>.NET Uygulamaları ile Entegrasyon:</strong> .NET ile başarılı bir şekilde entegre olarak modern .NET uygulamalarında sorunsuz bir kullanım sağlar.</li></ul><h3 id=signalr-ile-başlangıç>SignalR ile Başlangıç<a href=#signalr-ile-başlangıç class=hanchor arialabel=Anchor>&#8983;</a></h3><p>.NET projenize SignalR’ı entegre etmek için aşağıdaki adımları takip edebilirsiniz:</p><h3 id=1-signalr-nuget-paketi>1. SignalR NuGet Paketi<a href=#1-signalr-nuget-paketi class=hanchor arialabel=Anchor>&#8983;</a></h3><p>SignalR, .NET sistem kütüphaneleriyle birlikte gelir, bu nedenle ek bir paket yüklemenize gerek yoktur. Ancak Visual Studio saçmalamaya başlarsa <code>Microsoft.AspNetCore.SignalR</code> paketini yüklemeyi deneyebilirsiniz.</p><h3 id=2-hub-sınıfı-oluşturma>2. Hub Sınıfı Oluşturma<a href=#2-hub-sınıfı-oluşturma class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Hub, bağlantıları yöneten ve istemcilere mesaj gönderen merkezi bir bileşen görevi görür. Bu sınıfı, HTTP isteklerini kabul ettiğiniz Controller&rsquo;lara benzetebilirsiniz, ancak burada istemciden gelen istekleri kabul edebilir veya istemciye doğrudan istek gönderebilirsiniz. Basit bir örnek:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Microsoft.AspNetCore.SignalR;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NotificationsHub</span> : Hub
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task SendNotification(<span style=color:#66d9ef>string</span> content)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> Clients.All.SendAsync(<span style=color:#e6db74>&#34;ReceiveNotification&#34;</span>, content);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-programcs-dosyasında-hubı-yapılandırma>3. Program.cs Dosyasında Hub’ı Yapılandırma<a href=#3-programcs-dosyasında-hubı-yapılandırma class=hanchor arialabel=Anchor>&#8983;</a></h3><p>SignalR servislerini kaydedin ve hub uç noktasını şu şekilde eşleyin:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> builder = WebApplication.CreateBuilder(args);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>builder.Services.AddSignalR();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> app = builder.Build();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app.MapHub&lt;NotificationsHub&gt;(<span style=color:#e6db74>&#34;hubs/notification&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app.Run();
</span></span></code></pre></div><h3 id=4-signalr-istemcisi>4. SignalR İstemcisi<a href=#4-signalr-istemcisi class=hanchor arialabel=Anchor>&#8983;</a></h3><p>SignalR, Javascript, .NET ve Java gibi çeşitli istemci platformlarını destekler. Eğer bu platformlarda SignalR kütüphanesini uygulamak istemiyorsanız, uç noktanızı test etmek için basitçe Postman kullanabilirsiniz. Ancak JSON sonuna 0x1E karakterini eklemeniz gerekir. SignalR’ın dahili protokol gerekliliği budur. Javascript kütüphanesi kullanıyorsanız bu detayla uğraşmanıza gerek yoktur.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;protocol&#34;</span>: <span style=color:#e6db74>&#34;json&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;version&#34;</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>SignalR Hub’a mesaj göndermek ve almak için şu şekilde bir JSON kullanabilirsiniz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;arguments&#34;</span> : [<span style=color:#e6db74>&#34;hello world&#34;</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;target&#34;</span> : <span style=color:#e6db74>&#34;SendNotification&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;type&#34;</span> : <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kısa bir Postman ve SignalR demosu:</p><img src=/img/realtime-communication-with-signalr-a-deep-dive/postman-signalr-demo.gif alt="SignalR ve Postman demo" loading=lazy><p class=image-sub-title>SignalR ve Postman demo</p><h2 id=gelişmiş-özellikler>Gelişmiş Özellikler<a href=#gelişmiş-özellikler class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=1-tip-güvenli-hublar>1. Tip Güvenli Hub’lar<a href=#1-tip-güvenli-hublar class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Bakımı daha kolay hale getirmek için hub arayüzünü belirterek tip güvenli hub’lar kullanabilirsiniz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>INotificationsClient</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Task ReceiveNotification(<span style=color:#66d9ef>string</span> content);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NotificationsHub</span> : Hub&lt;INotificationsClient&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task SendNotification(<span style=color:#66d9ef>string</span> content)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> Clients.All.ReceiveNotification(content);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-belirli-istemcilere-mesaj-gönderme>2. Belirli İstemcilere Mesaj Gönderme<a href=#2-belirli-istemcilere-mesaj-gönderme class=hanchor arialabel=Anchor>&#8983;</a></h3><p>SignalR, belirli kullanıcılar veya gruplara mesaj gönderme yeteneğine sahiptir. Kullanıcıyı bir grup adına ekledikten sonra yalnızca ilgili kullanıcıya bildirim gönderebilirsiniz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>await</span> Clients.User(userId).ReceiveNotification(<span style=color:#e6db74>&#34;Hello, User!&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>await</span> Clients.Group(groupName).ReceiveNotification(<span style=color:#e6db74>&#34;Hello, Group!&#34;</span>);
</span></span></code></pre></div><p>Kullanıcı kimliği (userId) ile hedefleme yapmak için IUserIdProvider uygulamanız gerekir:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserIdProvider</span> : IUserIdProvider
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> GetUserId(HubConnectionContext connection)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> connection.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Program.cs</span>
</span></span><span style=display:flex><span>services.AddSingleton&lt;IUserIdProvider, CustomUserIdProvider&gt;();
</span></span></code></pre></div><h3 id=3-hub-dışından-ihubcontext-kullanımı>3. Hub Dışından IHubContext Kullanımı<a href=#3-hub-dışından-ihubcontext-kullanımı class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Hub dışında istemcilere mesaj göndermek için aşağıdaki şekilde bir yaklaşım izleyebilirsiniz. IHubContext türünü enjekte edin ve mesajınızı istemcilere gönderin.</p><p>Sisteminizde bir olay gerçekleştiğinde bu özelliği kullanarak hub&rsquo;ı tetikleyebilirsiniz. Örneğin, uzun süren bir toplu işlem tamamlandığında kullanıcılarınıza sonuç hakkında bildirim gönderebilirsiniz.</p><p>Kısa bir not: Kodunuzu daha temiz hale getirmek için bu IHubContext arayüzünü, örneğin <code>INotificationDispatcher</code> gibi başka bir arayüzle soyutlamanız iyi bir fikir olabilir.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NotificationDispatcher</span>(IHubContext&lt;NotificationsHub&gt; hubContext) : INotificationDispatcher
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task SendNotification(<span style=color:#66d9ef>string</span> content)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> hubContext.Clients.All.SendAsync(<span style=color:#e6db74>&#34;ReceiveNotification&#34;</span>, content);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task SendNotificationToUser(<span style=color:#66d9ef>string</span> userId, <span style=color:#66d9ef>string</span> content)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> hubContext.Clients.User(userId).SendAsync(<span style=color:#e6db74>&#34;ReceiveNotification&#34;</span>, content);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task SendNotificationToGroup(<span style=color:#66d9ef>string</span> groupName, <span style=color:#66d9ef>string</span> content)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> hubContext.Clients.Group(groupName).SendAsync(<span style=color:#e6db74>&#34;ReceiveNotification&#34;</span>, content);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>SignalR Güvenliğini Sağlama</li></ol><p>SignalR hub’larını [Authorize] özniteliği ile güvence altına alabilirsiniz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[Authorize]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NotificationsHub</span> : Hub
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Hub methods</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=5><li>Redis Backplane ile SignalR Ölçekleme</li></ol><p>SignalR’ı birden fazla sunucuya ölçeklendirmek, birden çok instance üzerinde çalışan yüksek talep gören uygulamalar için güvenilir gerçek zamanlı iletişim sağlar. Redis backplane, SignalR sunucuları arasındaki mesajları senkronize ederek, farklı sunuculara bağlı istemcilerin sorunsuz bir şekilde mesaj almasını sağlar. İşte Microsoft belgelerinden bir alıntı:</p><blockquote><p>SignalR Redis backplane, mesajları diğer sunuculara iletmek için pub/sub özelliğini kullanır. Bir istemci bağlantı kurduğunda, bağlantı bilgileri backplane’e iletilir. Bir sunucu tüm istemcilere mesaj göndermek istediğinde, bunu backplane’e iletir. Backplane, tüm bağlı istemcileri ve hangi sunucularda olduklarını bilir. Mesajı ilgili sunucular aracılığıyla tüm istemcilere gönderir.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>dotnet add package Microsoft.AspNetCore.SignalR.StackExchangeRedis
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Program.cs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>builder.Services.AddSignalR()
</span></span><span style=display:flex><span>    .AddStackExchangeRedis(<span style=color:#e6db74>&#34;localhost:6379&#34;</span>, options =&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        options.Configuration.ChannelPrefix = <span style=color:#e6db74>&#34;SignalR&#34;</span>;
</span></span><span style=display:flex><span>    });
</span></span></code></pre></div><p>Eğer bana inanmıyorsanız, SignalR uygulamanızı yerel test ortamında birden fazla instance ile çalıştırmayı Docker Compose kullanarak deneyebilirsiniz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>signalr</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>your-app</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;5000:5000&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>depends_on</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>redis</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>redis:latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;6379:6379&#34;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>docker-compose up --scale signalr<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>
</span></span></code></pre></div><h2 id=signalr-iletişim-modelleri>SignalR İletişim Modelleri<a href=#signalr-iletişim-modelleri class=hanchor arialabel=Anchor>&#8983;</a></h2><p>SignalR, uyumluluk ve performansı sağlamak için birden fazla taşıma yöntemini soyutlar:</p><h3 id=websocket-websockets><strong>WebSocket (</strong><code>webSockets</code><strong>)</strong>:<a href=#websocket-websockets class=hanchor arialabel=Anchor>&#8983;</a></h3><p>WebSockets, SignalR için en verimli ve tercih edilen gerçek zamanlı, çift yönlü iletişim yöntemidir. Tek bir TCP kanalı üzerinden kalıcı, tam çift yönlü bir bağlantı kurarak istemci ve sunucu arasında eşzamanlı mesaj alışverişine olanak tanır. Bu, canlı sohbetler, ortak düzenleme araçları, çevrimiçi oyunlar ve finansal veri akışları gibi düşük gecikme ve yüksek hız gerektiren uygulamalar için idealdir.</p><p>WebSockets, ilk HTTP el sıkışmasının ardından kendi hafif protokolüne (<code>ws://</code> veya <code>wss://</code>) geçerek geleneksel HTTP tabanlı iletişimin getirdiği yükü azaltır. Ancak, WebSockets&rsquo;in ölçeklendirilmesi, WebSocket uyumlu yük dengeleyiciler ve yapışkan oturumlar gibi özel altyapılar gerektirir. SignalR, bağlantı sürekliliğini, otomatik yeniden bağlantıları ve WebSockets kullanılamadığında alternatif protokollere geçişi yöneterek bu zorlukları basitleştirir.</p><h3 id=server-sent-events-serversentevents><strong>Server-Sent Events (</strong><code>serverSentEvents</code><strong>):</strong><a href=#server-sent-events-serversentevents class=hanchor arialabel=Anchor>&#8983;</a></h3><p>SSE (Server-Sent Events), uzun ömürlü bir bağlantı üzerinden sunucudan istemciye gerçek zamanlı güncellemeler sağlayan hafif bir HTTP tabanlı mekanizmadır. Standartlaştırılmış EventSource API&rsquo;sini kullanır ve verileri <code>text/event-stream</code> formatında iletir. Bu, canlı panolar, bildirimler ve haber akışları gibi yalnızca sunucudan istemciye veri aktarımı gerektiren durumlar için basit ve etkilidir.</p><p>SSE, standart HTTP üzerinde çalıştığı için mevcut HTTP altyapısı ile kolayca entegre olur ve WebSockets&rsquo;e kıyasla daha kolay ölçeklenebilir. Ancak, SSE Internet Explorer tarafından desteklenmez ve istemciden sunucuya iletişim gerektiren durumlar için ayrı HTTP istekleri gerektirir. SignalR, WebSockets kullanılamadığında otomatik olarak SSE&rsquo;yi tercih ederek kesintisiz bir deneyim sunar.</p><h3 id=long-polling-longpolling><strong>Long Polling (</strong><code>longPolling</code><strong>):</strong><a href=#long-polling-longpolling class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Long Polling, sürekli olarak HTTP bağlantıları açıp kapatarak gerçek zamanlı iletişimi taklit eder. İstemci, sunucuya bir istek gönderir ve sunucu veri gönderene kadar bağlantıyı açık tutar. Veriler iletildikten sonra istemci hemen yeni bir istek oluşturur. Bu yöntem, güncellemeler arasındaki gecikmeyi en aza indirir ve bir tür push tabanlı bağlantı hissi yaratır.</p><p>Long Polling, tüm tarayıcılarla çalışabilir ve uygulanması kolaydır. Ancak, sık HTTP istekleri ve yanıtları nedeniyle daha fazla yük oluşturur. Bu, özellikle yüksek frekanslı güncellemelerde, WebSockets veya SSE&rsquo;ye kıyasla daha az verimlidir. SignalR, WebSockets veya SSE desteklenmediğinde Long Polling’i bir yedek çözüm olarak kullanır.</p><h3 id=forever-frame-foreverframe><strong>Forever Frame (</strong><code>foreverFrame</code><strong>):</strong><a href=#forever-frame-foreverframe class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Forever Frame, eski Internet Explorer sürümlerine özgü bir protokoldür ve gerçek zamanlı, tek yönlü iletişim sağlar. İstemci tarayıcısında gizli bir iframe oluşturur ve sunucu bu iframe’e sürekli olarak çalıştırılabilir komut dosyaları gönderir.</p><p>Forever Frame, çift yönlü iletişimi desteklememesi ve yüksek ek yük getirmesi gibi sınırlamalara sahiptir. İstemciden sunucuya iletişim, ayrı standart HTTP istekleri gerektirir ve bu da uygulamayı daha az verimli ve zahmetli hale getirir. SignalR, yalnızca eski Internet Explorer tarayıcılarına özgü ortamlar için bir son çare olarak Forever Frame’i kullanır.</p><h3 id=websockets-ve-server-sent-events-karşılaştırması>WebSockets ve Server-Sent Events Karşılaştırması<a href=#websockets-ve-server-sent-events-karşılaştırması class=hanchor arialabel=Anchor>&#8983;</a></h3><p>WebSockets ve Server-Sent Events (SSE), farklı gerçek zamanlı iletişim ihtiyaçlarına hitap eder. <strong>WebSockets</strong>, düşük gecikmeli, çift yönlü iletişim sunarak sohbet, oyun ve ortak çalışma araçları için idealdir. <strong>SSE</strong> ise hafif, tek yönlü güncellemeler sağlayarak canlı panolar ve bildirimler gibi durumlar için mükemmeldir.</p><p>WebSockets, etkili iki yönlü mesajlaşma için özel bir protokol (<code>ws://</code> veya <code>wss://</code>) kullanır ancak ölçeklendirme için WebSocket uyumlu altyapı gerektirir. SSE ise standart HTTP (<code>text/event-stream</code>) üzerinde çalışır ve geleneksel HTTP araçları ile daha kolay ölçeklenebilir. Ancak, yalnızca sunucudan istemciye iletişim sağlar ve Internet Explorer desteği bulunmaz.</p><p>SignalR, bu farklılıkları soyutlayarak performans için WebSockets&rsquo;i önceliklendirir ve kesintisiz gerçek zamanlı işlevsellik sağlamak için SSE veya diğer yöntemlere otomatik olarak geçiş yapar.</p><h2 id=protokolü-belirleme>Protokolü Belirleme<a href=#protokolü-belirleme class=hanchor arialabel=Anchor>&#8983;</a></h2><p>SignalR, gerçek zamanlı iletişim için kullanılacak taşıma protokolünü açıkça belirtmenize olanak tanır. Varsayılan olarak, SignalR dahili algoritmasıyla mevcut en iyi protokolü otomatik olarak seçer. Ancak, bu davranışı uygulamanızın ihtiyaçlarına göre özelleştirebilirsiniz.</p><p>WebSockets’in verimliliğinden yararlanmak ve WebSockets kullanılamadığında Long Polling’e geçiş yapmak için <code>Program.cs</code> dosyasına şu kodu ekleyebilirsiniz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span>app.MapHub&lt;NotificationsHub&gt;(<span style=color:#e6db74>&#34;/hubs/notification&#34;</span>, opt =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    opt.Transports = HttpTransportType.WebSockets | HttpTransportType.LongPolling;
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>Veya istemci tarafında JavaScript ile şu şekilde yapılandırabilirsiniz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>connection</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>signalR</span>.<span style=color:#a6e22e>HubConnectionBuilder</span>()
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>withUrl</span>(<span style=color:#e6db74>&#34;/chathub&#34;</span>, { 
</span></span><span style=display:flex><span>	    <span style=color:#a6e22e>transport</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>signalR</span>.<span style=color:#a6e22e>HttpTransportType</span>.<span style=color:#a6e22e>WebSockets</span> 
</span></span><span style=display:flex><span>		    <span style=color:#f92672>|</span> <span style=color:#a6e22e>signalR</span>.<span style=color:#a6e22e>HttpTransportType</span>.<span style=color:#a6e22e>LongPolling</span> })
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>build</span>();
</span></span></code></pre></div><h2 id=özet>Özet<a href=#özet class=hanchor arialabel=Anchor>&#8983;</a></h2><p>SignalR, .NET uygulamalarına gerçek zamanlı özellikler eklemeyi kolay ve verimli hale getirir. Karmaşık ağ protokollerini soyutlayarak, alt yapı detaylarıyla uğraşmadan canlı panolar, sohbet uygulamaları veya bildirimler oluşturmanıza olanak tanır. WebSockets, Server-Sent Events (SSE) ve Long Polling gibi protokolleri destekleyen SignalR, ortamınıza en uygun protokolü otomatik olarak seçerek kesintisiz bir deneyim sunar.</p><p>Kaynak koduna erişmek isterseniz projenin tamamını GitHub hesabımda bulabilirsiniz:</p><p><a href=https://github.com/berkslv/lecture-signalr-deep-dive>GitHub - berkslv/lecture-signalr-deep-dive</a></p><hr><h2 id=sonuç>Sonuç<a href=#sonuç class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Okuduğunuz için teşekkürler! 🎉 Yazılım geliştirme alanındaki araştırmalarımı kaçırmamak için <a href=https://x.com/berkslv>@berkslv</a> adresinden takipte kalabilirsiniz.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://berkselvi.dev/tr/posts/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/><span class=button__text>Event-Driven Architecture: Mikroservis mimarisinde başka servislerin verilerine mi ihtiyacınız var</span>
<span class=button__icon>→</span></a></span></div></div><script src=https://utteranc.es/client.js repo=berkslv/berkselvi.dev issue-term=title theme=dark-blue crossorigin=anonymous async></script></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Made by Berk Selvi.<br>Bu websitesi <a href=https://github.com/berkslv/berkselvi.dev target=_blank>open source</a> olarak yayınlanmıştır.</span></div></div></footer><script src=https://berkselvi.dev/assets/main.js></script><script src=https://berkselvi.dev/assets/prism.js></script><script src=https://berkselvi.dev/assets/languageSelector.js></script></div></body></html>