<!doctype html><html lang=tr><head><title>SignalR ile GerÃ§ek ZamanlÄ± Ä°letiÅŸim: Derinlemesine Ä°nceleme :: Berk Selvi | Software Developer</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="GerÃ§ek zamanlÄ± iletiÅŸimin gÃ¼cÃ¼nÃ¼ SignalR ile keÅŸfedin! Bu blog yazÄ±sÄ±nda, SignalRâ€™Ä±n WebSockets, Server-Sent Events ve Long Polling gibi karmaÅŸÄ±k protokolleri soyutlayarak .NET uygulamalarÄ±nÄ±za canlÄ± Ã¶zellikler eklemeyi nasÄ±l kolaylaÅŸtÄ±rdÄ±ÄŸÄ±nÄ± Ã¶ÄŸrenin. SignalR'Ä± projenize kurmaktan, belirli kullanÄ±cÄ±larÄ± hedefleme ve Redis ile Ã¶lÃ§eklendirme gibi ileri dÃ¼zey Ã¶zelliklere kadar her ÅŸeyi bu rehberde bulabilirsiniz. SignalR dÃ¼nyasÄ±na adÄ±m atmaya hazÄ±r mÄ±sÄ±nÄ±z?"><meta name=keywords content="signalr,websocket,.NET,long polling"><meta name=robots content="noodp"><link rel=canonical href=https://berkselvi.dev/tr/posts/realtime-communication-with-signalr-a-deep-dive/><link rel=stylesheet href=https://berkselvi.dev/assets/style.css><link rel=stylesheet href=https://berkselvi.dev/assets/green.css><link rel=canonical href=https://berkselvi.dev/tr/posts/realtime-communication-with-signalr-a-deep-dive/><link rel=apple-touch-icon sizes=57x57 href=/icon/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/icon/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/icon/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/icon/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/icon/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/icon/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/icon/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/icon/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/icon/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/icon/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/icon/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/icon/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/icon/favicon-16x16.png><link rel=manifest href=/icon/manifest.json><meta name=msapplication-TileColor content="#1D1E28"><meta name=msapplication-TileImage content="/icon/ms-icon-144x144.png"><meta name=theme-color content="#1D1E28"><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="berkslv"><meta property="og:locale" content="tr"><meta property="og:type" content="article"><meta property="og:title" content="SignalR ile GerÃ§ek ZamanlÄ± Ä°letiÅŸim: Derinlemesine Ä°nceleme"><meta property="og:description" content="GerÃ§ek zamanlÄ± iletiÅŸimin gÃ¼cÃ¼nÃ¼ SignalR ile keÅŸfedin! Bu blog yazÄ±sÄ±nda, SignalRâ€™Ä±n WebSockets, Server-Sent Events ve Long Polling gibi karmaÅŸÄ±k protokolleri soyutlayarak .NET uygulamalarÄ±nÄ±za canlÄ± Ã¶zellikler eklemeyi nasÄ±l kolaylaÅŸtÄ±rdÄ±ÄŸÄ±nÄ± Ã¶ÄŸrenin. SignalR'Ä± projenize kurmaktan, belirli kullanÄ±cÄ±larÄ± hedefleme ve Redis ile Ã¶lÃ§eklendirme gibi ileri dÃ¼zey Ã¶zelliklere kadar her ÅŸeyi bu rehberde bulabilirsiniz. SignalR dÃ¼nyasÄ±na adÄ±m atmaya hazÄ±r mÄ±sÄ±nÄ±z?"><meta property="og:url" content="https://berkselvi.dev/tr/posts/realtime-communication-with-signalr-a-deep-dive/"><meta property="og:site_name" content="Berk Selvi | Software Developer"><meta property="og:image" content="https://berkselvi.dev/img/realtime-communication-with-signalr-a-deep-dive/cover.webp"><meta property="twitter:image" content="https://berkselvi.dev/img/realtime-communication-with-signalr-a-deep-dive/cover.webp"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2024-11-29 00:00:00 +0300 +0300"><script async src="https://www.googletagmanager.com/gtag/js?id=G-W0L24EMSQ5"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W0L24EMSQ5")</script><link href=https://berkselvi.dev/css/custom.css rel=stylesheet></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=menu-trigger><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu"><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/></svg></div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/tr>ana sayfa</a></li><div class=spacer></div><ul class=language-selector><ul class=language-selector-current><li>tÃ¼rkÃ§e â–¾</li></ul><ul class="language-selector__more hidden"><li><a href=https://berkselvi.dev/>english</a></li><li><a href=https://berkselvi.dev/tr/>tÃ¼rkÃ§e</a></li></ul></ul></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/tr>ana sayfa</a></li><hr><li><a href=https://berkselvi.dev/>english</a></li><li><a href=https://berkselvi.dev/tr/>tÃ¼rkÃ§e</a></li></ul></nav></header><div class=content><div class=post><h4>Translations;</h4><a href=/posts/realtime-communication-with-signalr-a-deep-dive/>Real-Time Communication with SignalR: A Deep Dive</a><h1 class=post-title><a href=https://berkselvi.dev/tr/posts/realtime-communication-with-signalr-a-deep-dive/>SignalR ile GerÃ§ek ZamanlÄ± Ä°letiÅŸim: Derinlemesine Ä°nceleme</a></h1><div class=post-meta><span class=post-date>29 KasÄ±m 2024
</span><span class=post-author>:: Berk Selvi</span>
<span class=post-reading-time>:: 7 min read (1479 words)</span></div><div class=post-content><div><p>GÃ¼nÃ¼mÃ¼z dÃ¼nyasÄ±nda verilerin hÄ±zla hareket ettiÄŸi bir ortamda, modern uygulamalarÄ±n kullanÄ±cÄ±larÄ±na sorunsuz deneyimler sunabilmesi iÃ§in gerÃ§ek zamanlÄ± iletiÅŸim bir zorunluluk haline gelmiÅŸtir. SignalR, .NET uygulamalarÄ± iÃ§in gerÃ§ek zamanlÄ± iletiÅŸim Ã¶zelliklerini kolayca hayata geÃ§irmenize yardÄ±mcÄ± olan temel bir kÃ¼tÃ¼phanedir. SignalR kullanÄ±rken tÃ¼m iletiÅŸim ve network gereksinimleri kÃ¼tÃ¼phane tarafÄ±ndan soyutlanÄ±r; sadece bir RPC Ã§aÄŸrÄ±sÄ± yapar gibi yÃ¶ntem Ã§aÄŸrÄ±sÄ±nda bulunmanÄ±z yeterlidir. SignalR sayesinde canlÄ± panolar, sohbet uygulamalarÄ± veya web uygulamalarÄ±nda sÄ±kÃ§a ihtiyaÃ§ duyulan basit bildirim Ã¶zelliklerini kolayca oluÅŸturabilirsiniz. Haydi baÅŸlayalÄ±m.</p><h2 id=neden-signalr>Neden SignalR?<a href=#neden-signalr class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Geleneksel istemci-sunucu iletiÅŸim modelleri, yÃ¼ksek etkileÅŸim ihtiyaÃ§larÄ± iÃ§in daha az verimli ve sÄ±nÄ±rlÄ± olan istek-cevap modeline dayanÄ±r ve veriye ihtiyaÃ§ duyulduÄŸunda istemcinin bir istek gÃ¶ndermesini gerektirir. SignalR, istemci ile sunucu arasÄ±ndaki aynÄ± baÄŸlantÄ±yÄ± sÃ¼rekli aÃ§Ä±k tutarak bu zorluklarÄ± ortadan kaldÄ±rmak iÃ§in tasarlanmÄ±ÅŸtÄ±r.</p><h3 id=signalrÄ±n-temel-avantajlarÄ±>SignalRâ€™Ä±n Temel AvantajlarÄ±:<a href=#signalrÄ±n-temel-avantajlarÄ± class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li><strong>GerÃ§ek ZamanlÄ± Ä°letiÅŸim:</strong> Ä°stemciler, yeni bir istek gÃ¶ndermeye gerek kalmadan anÄ±nda gÃ¼ncellemeleri alÄ±r.</li><li><strong>Ã‡apraz Platform DesteÄŸi:</strong> SignalR, platform ve tarayÄ±cÄ±dan baÄŸÄ±msÄ±zdÄ±r.</li><li><strong>KarmaÅŸÄ±k Protokollerin SoyutlanmasÄ±:</strong> SignalR, WebSocket, Server-Sent Events ve Long Polling protokollerini kullanma yeteneÄŸine sahiptir. Bu, istemci ve sunucu arasÄ±nda daha verimli bir iliÅŸki saÄŸlar ve en uygun protokolÃ¼n seÃ§ilmesine olanak tanÄ±r. WebSocket protokolÃ¼ istemci tarafÄ±ndan desteklenmiyorsa, SignalR kendi iÃ§ algoritmasÄ±na gÃ¶re diÄŸer yÃ¶ntemleri seÃ§erek kullanÄ±r.</li><li><strong>.NET UygulamalarÄ± ile Entegrasyon:</strong> .NET ile baÅŸarÄ±lÄ± bir ÅŸekilde entegre olarak modern .NET uygulamalarÄ±nda sorunsuz bir kullanÄ±m saÄŸlar.</li></ul><h3 id=signalr-ile-baÅŸlangÄ±Ã§>SignalR ile BaÅŸlangÄ±Ã§<a href=#signalr-ile-baÅŸlangÄ±Ã§ class=hanchor arialabel=Anchor>&#8983;</a></h3><p>.NET projenize SignalRâ€™Ä± entegre etmek iÃ§in aÅŸaÄŸÄ±daki adÄ±mlarÄ± takip edebilirsiniz:</p><h3 id=1-signalr-nuget-paketi>1. SignalR NuGet Paketi<a href=#1-signalr-nuget-paketi class=hanchor arialabel=Anchor>&#8983;</a></h3><p>SignalR, .NET sistem kÃ¼tÃ¼phaneleriyle birlikte gelir, bu nedenle ek bir paket yÃ¼klemenize gerek yoktur. Ancak Visual Studio saÃ§malamaya baÅŸlarsa <code>Microsoft.AspNetCore.SignalR</code> paketini yÃ¼klemeyi deneyebilirsiniz.</p><h3 id=2-hub-sÄ±nÄ±fÄ±-oluÅŸturma>2. Hub SÄ±nÄ±fÄ± OluÅŸturma<a href=#2-hub-sÄ±nÄ±fÄ±-oluÅŸturma class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Hub, baÄŸlantÄ±larÄ± yÃ¶neten ve istemcilere mesaj gÃ¶nderen merkezi bir bileÅŸen gÃ¶revi gÃ¶rÃ¼r. Bu sÄ±nÄ±fÄ±, HTTP isteklerini kabul ettiÄŸiniz Controller&rsquo;lara benzetebilirsiniz, ancak burada istemciden gelen istekleri kabul edebilir veya istemciye doÄŸrudan istek gÃ¶nderebilirsiniz. Basit bir Ã¶rnek:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Microsoft.AspNetCore.SignalR;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NotificationsHub</span> : Hub
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task SendNotification(<span style=color:#66d9ef>string</span> content)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> Clients.All.SendAsync(<span style=color:#e6db74>&#34;ReceiveNotification&#34;</span>, content);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-programcs-dosyasÄ±nda-hubÄ±-yapÄ±landÄ±rma>3. Program.cs DosyasÄ±nda Hubâ€™Ä± YapÄ±landÄ±rma<a href=#3-programcs-dosyasÄ±nda-hubÄ±-yapÄ±landÄ±rma class=hanchor arialabel=Anchor>&#8983;</a></h3><p>SignalR servislerini kaydedin ve hub uÃ§ noktasÄ±nÄ± ÅŸu ÅŸekilde eÅŸleyin:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> builder = WebApplication.CreateBuilder(args);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>builder.Services.AddSignalR();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> app = builder.Build();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app.MapHub&lt;NotificationsHub&gt;(<span style=color:#e6db74>&#34;hubs/notification&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app.Run();
</span></span></code></pre></div><h3 id=4-signalr-istemcisi>4. SignalR Ä°stemcisi<a href=#4-signalr-istemcisi class=hanchor arialabel=Anchor>&#8983;</a></h3><p>SignalR, Javascript, .NET ve Java gibi Ã§eÅŸitli istemci platformlarÄ±nÄ± destekler. EÄŸer bu platformlarda SignalR kÃ¼tÃ¼phanesini uygulamak istemiyorsanÄ±z, uÃ§ noktanÄ±zÄ± test etmek iÃ§in basitÃ§e Postman kullanabilirsiniz. Ancak JSON sonuna 0x1E karakterini eklemeniz gerekir. SignalRâ€™Ä±n dahili protokol gerekliliÄŸi budur. Javascript kÃ¼tÃ¼phanesi kullanÄ±yorsanÄ±z bu detayla uÄŸraÅŸmanÄ±za gerek yoktur.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;protocol&#34;</span>: <span style=color:#e6db74>&#34;json&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;version&#34;</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>SignalR Hubâ€™a mesaj gÃ¶ndermek ve almak iÃ§in ÅŸu ÅŸekilde bir JSON kullanabilirsiniz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;arguments&#34;</span> : [<span style=color:#e6db74>&#34;hello world&#34;</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;target&#34;</span> : <span style=color:#e6db74>&#34;SendNotification&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;type&#34;</span> : <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>KÄ±sa bir Postman ve SignalR demosu:</p><img src=/img/realtime-communication-with-signalr-a-deep-dive/postman-signalr-demo.gif alt="SignalR ve Postman demo" loading=lazy><p class=image-sub-title>SignalR ve Postman demo</p><h2 id=geliÅŸmiÅŸ-Ã¶zellikler>GeliÅŸmiÅŸ Ã–zellikler<a href=#geliÅŸmiÅŸ-Ã¶zellikler class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=1-tip-gÃ¼venli-hublar>1. Tip GÃ¼venli Hubâ€™lar<a href=#1-tip-gÃ¼venli-hublar class=hanchor arialabel=Anchor>&#8983;</a></h3><p>BakÄ±mÄ± daha kolay hale getirmek iÃ§in hub arayÃ¼zÃ¼nÃ¼ belirterek tip gÃ¼venli hubâ€™lar kullanabilirsiniz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>INotificationsClient</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Task ReceiveNotification(<span style=color:#66d9ef>string</span> content);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NotificationsHub</span> : Hub&lt;INotificationsClient&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task SendNotification(<span style=color:#66d9ef>string</span> content)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> Clients.All.ReceiveNotification(content);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-belirli-istemcilere-mesaj-gÃ¶nderme>2. Belirli Ä°stemcilere Mesaj GÃ¶nderme<a href=#2-belirli-istemcilere-mesaj-gÃ¶nderme class=hanchor arialabel=Anchor>&#8983;</a></h3><p>SignalR, belirli kullanÄ±cÄ±lar veya gruplara mesaj gÃ¶nderme yeteneÄŸine sahiptir. KullanÄ±cÄ±yÄ± bir grup adÄ±na ekledikten sonra yalnÄ±zca ilgili kullanÄ±cÄ±ya bildirim gÃ¶nderebilirsiniz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>await</span> Clients.User(userId).ReceiveNotification(<span style=color:#e6db74>&#34;Hello, User!&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>await</span> Clients.Group(groupName).ReceiveNotification(<span style=color:#e6db74>&#34;Hello, Group!&#34;</span>);
</span></span></code></pre></div><p>KullanÄ±cÄ± kimliÄŸi (userId) ile hedefleme yapmak iÃ§in IUserIdProvider uygulamanÄ±z gerekir:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserIdProvider</span> : IUserIdProvider
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> GetUserId(HubConnectionContext connection)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> connection.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Program.cs</span>
</span></span><span style=display:flex><span>services.AddSingleton&lt;IUserIdProvider, CustomUserIdProvider&gt;();
</span></span></code></pre></div><h3 id=3-hub-dÄ±ÅŸÄ±ndan-ihubcontext-kullanÄ±mÄ±>3. Hub DÄ±ÅŸÄ±ndan IHubContext KullanÄ±mÄ±<a href=#3-hub-dÄ±ÅŸÄ±ndan-ihubcontext-kullanÄ±mÄ± class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Hub dÄ±ÅŸÄ±nda istemcilere mesaj gÃ¶ndermek iÃ§in aÅŸaÄŸÄ±daki ÅŸekilde bir yaklaÅŸÄ±m izleyebilirsiniz. IHubContext tÃ¼rÃ¼nÃ¼ enjekte edin ve mesajÄ±nÄ±zÄ± istemcilere gÃ¶nderin.</p><p>Sisteminizde bir olay gerÃ§ekleÅŸtiÄŸinde bu Ã¶zelliÄŸi kullanarak hub&rsquo;Ä± tetikleyebilirsiniz. Ã–rneÄŸin, uzun sÃ¼ren bir toplu iÅŸlem tamamlandÄ±ÄŸÄ±nda kullanÄ±cÄ±larÄ±nÄ±za sonuÃ§ hakkÄ±nda bildirim gÃ¶nderebilirsiniz.</p><p>KÄ±sa bir not: Kodunuzu daha temiz hale getirmek iÃ§in bu IHubContext arayÃ¼zÃ¼nÃ¼, Ã¶rneÄŸin <code>INotificationDispatcher</code> gibi baÅŸka bir arayÃ¼zle soyutlamanÄ±z iyi bir fikir olabilir.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NotificationDispatcher</span>(IHubContext&lt;NotificationsHub&gt; hubContext) : INotificationDispatcher
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task SendNotification(<span style=color:#66d9ef>string</span> content)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> hubContext.Clients.All.SendAsync(<span style=color:#e6db74>&#34;ReceiveNotification&#34;</span>, content);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task SendNotificationToUser(<span style=color:#66d9ef>string</span> userId, <span style=color:#66d9ef>string</span> content)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> hubContext.Clients.User(userId).SendAsync(<span style=color:#e6db74>&#34;ReceiveNotification&#34;</span>, content);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task SendNotificationToGroup(<span style=color:#66d9ef>string</span> groupName, <span style=color:#66d9ef>string</span> content)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> hubContext.Clients.Group(groupName).SendAsync(<span style=color:#e6db74>&#34;ReceiveNotification&#34;</span>, content);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>SignalR GÃ¼venliÄŸini SaÄŸlama</li></ol><p>SignalR hubâ€™larÄ±nÄ± [Authorize] Ã¶zniteliÄŸi ile gÃ¼vence altÄ±na alabilirsiniz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[Authorize]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NotificationsHub</span> : Hub
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Hub methods</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=5><li>Redis Backplane ile SignalR Ã–lÃ§ekleme</li></ol><p>SignalRâ€™Ä± birden fazla sunucuya Ã¶lÃ§eklendirmek, birden Ã§ok instance Ã¼zerinde Ã§alÄ±ÅŸan yÃ¼ksek talep gÃ¶ren uygulamalar iÃ§in gÃ¼venilir gerÃ§ek zamanlÄ± iletiÅŸim saÄŸlar. Redis backplane, SignalR sunucularÄ± arasÄ±ndaki mesajlarÄ± senkronize ederek, farklÄ± sunuculara baÄŸlÄ± istemcilerin sorunsuz bir ÅŸekilde mesaj almasÄ±nÄ± saÄŸlar. Ä°ÅŸte Microsoft belgelerinden bir alÄ±ntÄ±:</p><blockquote><p>SignalR Redis backplane, mesajlarÄ± diÄŸer sunuculara iletmek iÃ§in pub/sub Ã¶zelliÄŸini kullanÄ±r. Bir istemci baÄŸlantÄ± kurduÄŸunda, baÄŸlantÄ± bilgileri backplaneâ€™e iletilir. Bir sunucu tÃ¼m istemcilere mesaj gÃ¶ndermek istediÄŸinde, bunu backplaneâ€™e iletir. Backplane, tÃ¼m baÄŸlÄ± istemcileri ve hangi sunucularda olduklarÄ±nÄ± bilir. MesajÄ± ilgili sunucular aracÄ±lÄ±ÄŸÄ±yla tÃ¼m istemcilere gÃ¶nderir.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>dotnet add package Microsoft.AspNetCore.SignalR.StackExchangeRedis
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Program.cs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>builder.Services.AddSignalR()
</span></span><span style=display:flex><span>    .AddStackExchangeRedis(<span style=color:#e6db74>&#34;localhost:6379&#34;</span>, options =&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        options.Configuration.ChannelPrefix = <span style=color:#e6db74>&#34;SignalR&#34;</span>;
</span></span><span style=display:flex><span>    });
</span></span></code></pre></div><p>EÄŸer bana inanmÄ±yorsanÄ±z, SignalR uygulamanÄ±zÄ± yerel test ortamÄ±nda birden fazla instance ile Ã§alÄ±ÅŸtÄ±rmayÄ± Docker Compose kullanarak deneyebilirsiniz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>signalr</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>your-app</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;5000:5000&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>depends_on</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>redis</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>redis:latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;6379:6379&#34;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>docker-compose up --scale signalr<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>
</span></span></code></pre></div><h2 id=signalr-iletiÅŸim-modelleri>SignalR Ä°letiÅŸim Modelleri<a href=#signalr-iletiÅŸim-modelleri class=hanchor arialabel=Anchor>&#8983;</a></h2><p>SignalR, uyumluluk ve performansÄ± saÄŸlamak iÃ§in birden fazla taÅŸÄ±ma yÃ¶ntemini soyutlar:</p><h3 id=websocket-websockets><strong>WebSocket (</strong><code>webSockets</code><strong>)</strong>:<a href=#websocket-websockets class=hanchor arialabel=Anchor>&#8983;</a></h3><p>WebSockets, SignalR iÃ§in en verimli ve tercih edilen gerÃ§ek zamanlÄ±, Ã§ift yÃ¶nlÃ¼ iletiÅŸim yÃ¶ntemidir. Tek bir TCP kanalÄ± Ã¼zerinden kalÄ±cÄ±, tam Ã§ift yÃ¶nlÃ¼ bir baÄŸlantÄ± kurarak istemci ve sunucu arasÄ±nda eÅŸzamanlÄ± mesaj alÄ±ÅŸveriÅŸine olanak tanÄ±r. Bu, canlÄ± sohbetler, ortak dÃ¼zenleme araÃ§larÄ±, Ã§evrimiÃ§i oyunlar ve finansal veri akÄ±ÅŸlarÄ± gibi dÃ¼ÅŸÃ¼k gecikme ve yÃ¼ksek hÄ±z gerektiren uygulamalar iÃ§in idealdir.</p><p>WebSockets, ilk HTTP el sÄ±kÄ±ÅŸmasÄ±nÄ±n ardÄ±ndan kendi hafif protokolÃ¼ne (<code>ws://</code> veya <code>wss://</code>) geÃ§erek geleneksel HTTP tabanlÄ± iletiÅŸimin getirdiÄŸi yÃ¼kÃ¼ azaltÄ±r. Ancak, WebSockets&rsquo;in Ã¶lÃ§eklendirilmesi, WebSocket uyumlu yÃ¼k dengeleyiciler ve yapÄ±ÅŸkan oturumlar gibi Ã¶zel altyapÄ±lar gerektirir. SignalR, baÄŸlantÄ± sÃ¼rekliliÄŸini, otomatik yeniden baÄŸlantÄ±larÄ± ve WebSockets kullanÄ±lamadÄ±ÄŸÄ±nda alternatif protokollere geÃ§iÅŸi yÃ¶neterek bu zorluklarÄ± basitleÅŸtirir.</p><h3 id=server-sent-events-serversentevents><strong>Server-Sent Events (</strong><code>serverSentEvents</code><strong>):</strong><a href=#server-sent-events-serversentevents class=hanchor arialabel=Anchor>&#8983;</a></h3><p>SSE (Server-Sent Events), uzun Ã¶mÃ¼rlÃ¼ bir baÄŸlantÄ± Ã¼zerinden sunucudan istemciye gerÃ§ek zamanlÄ± gÃ¼ncellemeler saÄŸlayan hafif bir HTTP tabanlÄ± mekanizmadÄ±r. StandartlaÅŸtÄ±rÄ±lmÄ±ÅŸ EventSource API&rsquo;sini kullanÄ±r ve verileri <code>text/event-stream</code> formatÄ±nda iletir. Bu, canlÄ± panolar, bildirimler ve haber akÄ±ÅŸlarÄ± gibi yalnÄ±zca sunucudan istemciye veri aktarÄ±mÄ± gerektiren durumlar iÃ§in basit ve etkilidir.</p><p>SSE, standart HTTP Ã¼zerinde Ã§alÄ±ÅŸtÄ±ÄŸÄ± iÃ§in mevcut HTTP altyapÄ±sÄ± ile kolayca entegre olur ve WebSockets&rsquo;e kÄ±yasla daha kolay Ã¶lÃ§eklenebilir. Ancak, SSE Internet Explorer tarafÄ±ndan desteklenmez ve istemciden sunucuya iletiÅŸim gerektiren durumlar iÃ§in ayrÄ± HTTP istekleri gerektirir. SignalR, WebSockets kullanÄ±lamadÄ±ÄŸÄ±nda otomatik olarak SSE&rsquo;yi tercih ederek kesintisiz bir deneyim sunar.</p><h3 id=long-polling-longpolling><strong>Long Polling (</strong><code>longPolling</code><strong>):</strong><a href=#long-polling-longpolling class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Long Polling, sÃ¼rekli olarak HTTP baÄŸlantÄ±larÄ± aÃ§Ä±p kapatarak gerÃ§ek zamanlÄ± iletiÅŸimi taklit eder. Ä°stemci, sunucuya bir istek gÃ¶nderir ve sunucu veri gÃ¶nderene kadar baÄŸlantÄ±yÄ± aÃ§Ä±k tutar. Veriler iletildikten sonra istemci hemen yeni bir istek oluÅŸturur. Bu yÃ¶ntem, gÃ¼ncellemeler arasÄ±ndaki gecikmeyi en aza indirir ve bir tÃ¼r push tabanlÄ± baÄŸlantÄ± hissi yaratÄ±r.</p><p>Long Polling, tÃ¼m tarayÄ±cÄ±larla Ã§alÄ±ÅŸabilir ve uygulanmasÄ± kolaydÄ±r. Ancak, sÄ±k HTTP istekleri ve yanÄ±tlarÄ± nedeniyle daha fazla yÃ¼k oluÅŸturur. Bu, Ã¶zellikle yÃ¼ksek frekanslÄ± gÃ¼ncellemelerde, WebSockets veya SSE&rsquo;ye kÄ±yasla daha az verimlidir. SignalR, WebSockets veya SSE desteklenmediÄŸinde Long Pollingâ€™i bir yedek Ã§Ã¶zÃ¼m olarak kullanÄ±r.</p><h3 id=forever-frame-foreverframe><strong>Forever Frame (</strong><code>foreverFrame</code><strong>):</strong><a href=#forever-frame-foreverframe class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Forever Frame, eski Internet Explorer sÃ¼rÃ¼mlerine Ã¶zgÃ¼ bir protokoldÃ¼r ve gerÃ§ek zamanlÄ±, tek yÃ¶nlÃ¼ iletiÅŸim saÄŸlar. Ä°stemci tarayÄ±cÄ±sÄ±nda gizli bir iframe oluÅŸturur ve sunucu bu iframeâ€™e sÃ¼rekli olarak Ã§alÄ±ÅŸtÄ±rÄ±labilir komut dosyalarÄ± gÃ¶nderir.</p><p>Forever Frame, Ã§ift yÃ¶nlÃ¼ iletiÅŸimi desteklememesi ve yÃ¼ksek ek yÃ¼k getirmesi gibi sÄ±nÄ±rlamalara sahiptir. Ä°stemciden sunucuya iletiÅŸim, ayrÄ± standart HTTP istekleri gerektirir ve bu da uygulamayÄ± daha az verimli ve zahmetli hale getirir. SignalR, yalnÄ±zca eski Internet Explorer tarayÄ±cÄ±larÄ±na Ã¶zgÃ¼ ortamlar iÃ§in bir son Ã§are olarak Forever Frameâ€™i kullanÄ±r.</p><h3 id=websockets-ve-server-sent-events-karÅŸÄ±laÅŸtÄ±rmasÄ±>WebSockets ve Server-Sent Events KarÅŸÄ±laÅŸtÄ±rmasÄ±<a href=#websockets-ve-server-sent-events-karÅŸÄ±laÅŸtÄ±rmasÄ± class=hanchor arialabel=Anchor>&#8983;</a></h3><p>WebSockets ve Server-Sent Events (SSE), farklÄ± gerÃ§ek zamanlÄ± iletiÅŸim ihtiyaÃ§larÄ±na hitap eder. <strong>WebSockets</strong>, dÃ¼ÅŸÃ¼k gecikmeli, Ã§ift yÃ¶nlÃ¼ iletiÅŸim sunarak sohbet, oyun ve ortak Ã§alÄ±ÅŸma araÃ§larÄ± iÃ§in idealdir. <strong>SSE</strong> ise hafif, tek yÃ¶nlÃ¼ gÃ¼ncellemeler saÄŸlayarak canlÄ± panolar ve bildirimler gibi durumlar iÃ§in mÃ¼kemmeldir.</p><p>WebSockets, etkili iki yÃ¶nlÃ¼ mesajlaÅŸma iÃ§in Ã¶zel bir protokol (<code>ws://</code> veya <code>wss://</code>) kullanÄ±r ancak Ã¶lÃ§eklendirme iÃ§in WebSocket uyumlu altyapÄ± gerektirir. SSE ise standart HTTP (<code>text/event-stream</code>) Ã¼zerinde Ã§alÄ±ÅŸÄ±r ve geleneksel HTTP araÃ§larÄ± ile daha kolay Ã¶lÃ§eklenebilir. Ancak, yalnÄ±zca sunucudan istemciye iletiÅŸim saÄŸlar ve Internet Explorer desteÄŸi bulunmaz.</p><p>SignalR, bu farklÄ±lÄ±klarÄ± soyutlayarak performans iÃ§in WebSockets&rsquo;i Ã¶nceliklendirir ve kesintisiz gerÃ§ek zamanlÄ± iÅŸlevsellik saÄŸlamak iÃ§in SSE veya diÄŸer yÃ¶ntemlere otomatik olarak geÃ§iÅŸ yapar.</p><h2 id=protokolÃ¼-belirleme>ProtokolÃ¼ Belirleme<a href=#protokolÃ¼-belirleme class=hanchor arialabel=Anchor>&#8983;</a></h2><p>SignalR, gerÃ§ek zamanlÄ± iletiÅŸim iÃ§in kullanÄ±lacak taÅŸÄ±ma protokolÃ¼nÃ¼ aÃ§Ä±kÃ§a belirtmenize olanak tanÄ±r. VarsayÄ±lan olarak, SignalR dahili algoritmasÄ±yla mevcut en iyi protokolÃ¼ otomatik olarak seÃ§er. Ancak, bu davranÄ±ÅŸÄ± uygulamanÄ±zÄ±n ihtiyaÃ§larÄ±na gÃ¶re Ã¶zelleÅŸtirebilirsiniz.</p><p>WebSocketsâ€™in verimliliÄŸinden yararlanmak ve WebSockets kullanÄ±lamadÄ±ÄŸÄ±nda Long Pollingâ€™e geÃ§iÅŸ yapmak iÃ§in <code>Program.cs</code> dosyasÄ±na ÅŸu kodu ekleyebilirsiniz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span>app.MapHub&lt;NotificationsHub&gt;(<span style=color:#e6db74>&#34;/hubs/notification&#34;</span>, opt =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    opt.Transports = HttpTransportType.WebSockets | HttpTransportType.LongPolling;
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>Veya istemci tarafÄ±nda JavaScript ile ÅŸu ÅŸekilde yapÄ±landÄ±rabilirsiniz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>connection</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>signalR</span>.<span style=color:#a6e22e>HubConnectionBuilder</span>()
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>withUrl</span>(<span style=color:#e6db74>&#34;/chathub&#34;</span>, { 
</span></span><span style=display:flex><span>	    <span style=color:#a6e22e>transport</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>signalR</span>.<span style=color:#a6e22e>HttpTransportType</span>.<span style=color:#a6e22e>WebSockets</span> 
</span></span><span style=display:flex><span>		    <span style=color:#f92672>|</span> <span style=color:#a6e22e>signalR</span>.<span style=color:#a6e22e>HttpTransportType</span>.<span style=color:#a6e22e>LongPolling</span> })
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>build</span>();
</span></span></code></pre></div><h2 id=Ã¶zet>Ã–zet<a href=#Ã¶zet class=hanchor arialabel=Anchor>&#8983;</a></h2><p>SignalR, .NET uygulamalarÄ±na gerÃ§ek zamanlÄ± Ã¶zellikler eklemeyi kolay ve verimli hale getirir. KarmaÅŸÄ±k aÄŸ protokollerini soyutlayarak, alt yapÄ± detaylarÄ±yla uÄŸraÅŸmadan canlÄ± panolar, sohbet uygulamalarÄ± veya bildirimler oluÅŸturmanÄ±za olanak tanÄ±r. WebSockets, Server-Sent Events (SSE) ve Long Polling gibi protokolleri destekleyen SignalR, ortamÄ±nÄ±za en uygun protokolÃ¼ otomatik olarak seÃ§erek kesintisiz bir deneyim sunar.</p><p>Kaynak koduna eriÅŸmek isterseniz projenin tamamÄ±nÄ± GitHub hesabÄ±mda bulabilirsiniz:</p><p><a href=https://github.com/berkslv/lecture-signalr-deep-dive>GitHub - berkslv/lecture-signalr-deep-dive</a></p><hr><h2 id=sonuÃ§>SonuÃ§<a href=#sonuÃ§ class=hanchor arialabel=Anchor>&#8983;</a></h2><p>OkuduÄŸunuz iÃ§in teÅŸekkÃ¼rler! ğŸ‰ YazÄ±lÄ±m geliÅŸtirme alanÄ±ndaki araÅŸtÄ±rmalarÄ±mÄ± kaÃ§Ä±rmamak iÃ§in <a href=https://x.com/berkslv>@berkslv</a> adresinden takipte kalabilirsiniz.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://berkselvi.dev/tr/posts/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/><span class=button__text>Event-Driven Architecture: Mikroservis mimarisinde baÅŸka servislerin verilerine mi ihtiyacÄ±nÄ±z var</span>
<span class=button__icon>â†’</span></a></span></div></div><script src=https://utteranc.es/client.js repo=berkslv/berkselvi.dev issue-term=title theme=dark-blue crossorigin=anonymous async></script></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Made by Berk Selvi.<br>Bu websitesi <a href=https://github.com/berkslv/berkselvi.dev target=_blank>open source</a> olarak yayÄ±nlanmÄ±ÅŸtÄ±r.</span></div></div></footer><script src=https://berkselvi.dev/assets/main.js></script><script src=https://berkselvi.dev/assets/prism.js></script><script src=https://berkselvi.dev/assets/languageSelector.js></script></div></body></html>