<!doctype html><html lang=en><head><title>CorrelationId Tracing in .NET Microservices with HTTP and MassTransit :: Berk Selvi | Software Developer</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="In this article on .NET microservice architecture, we will explore how to use CorrelationId with HTTP and RabbitMQ requests to enhance distributed traceability. We will examine how to propagate the CorrelationId value across different services, manipulate header values in incoming and outgoing requests using Middleware and Filter structures, and log contexts using Serilog's LogContext framework."><meta name=keywords content="microservices,correlationId,distributed tracing,middleware,AsyncLocal"><meta name=robots content="noodp"><link rel=canonical href=https://berkselvi.dev/posts/correlationid-tracing-net-microservices-with-http-and-rabbitmq/><link rel=stylesheet href=https://berkselvi.dev/assets/style.css><link rel=stylesheet href=https://berkselvi.dev/assets/green.css><link rel=canonical href=https://berkselvi.dev/posts/correlationid-tracing-net-microservices-with-http-and-rabbitmq/><link rel=apple-touch-icon sizes=57x57 href=/icon/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/icon/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/icon/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/icon/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/icon/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/icon/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/icon/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/icon/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/icon/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/icon/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/icon/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/icon/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/icon/favicon-16x16.png><link rel=manifest href=/icon/manifest.json><meta name=msapplication-TileColor content="#1D1E28"><meta name=msapplication-TileImage content="/icon/ms-icon-144x144.png"><meta name=theme-color content="#1D1E28"><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="berkslv"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="CorrelationId Tracing in .NET Microservices with HTTP and MassTransit"><meta property="og:description" content="In this article on .NET microservice architecture, we will explore how to use CorrelationId with HTTP and RabbitMQ requests to enhance distributed traceability. We will examine how to propagate the CorrelationId value across different services, manipulate header values in incoming and outgoing requests using Middleware and Filter structures, and log contexts using Serilog's LogContext framework."><meta property="og:url" content="https://berkselvi.dev/posts/correlationid-tracing-net-microservices-with-http-and-rabbitmq/"><meta property="og:site_name" content="Berk Selvi | Software Developer"><meta property="og:image" content="https://berkselvi.dev/img/correlationid-tracing-net-microservices-with-http-and-rabbitmq/cover.webp"><meta property="twitter:image" content="https://berkselvi.dev/img/correlationid-tracing-net-microservices-with-http-and-rabbitmq/cover.webp"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2024-07-14 00:00:00 +0300 +0300"><script async src="https://www.googletagmanager.com/gtag/js?id=G-W0L24EMSQ5"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W0L24EMSQ5")</script><link href=https://berkselvi.dev/css/custom.css rel=stylesheet></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=menu-trigger><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu"><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/></svg></div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>home</a></li><div class=spacer></div><ul class=language-selector><ul class=language-selector-current><li>english ▾</li></ul><ul class="language-selector__more hidden"><li><a href=https://berkselvi.dev/>english</a></li><li><a href=https://berkselvi.dev/tr/>türkçe</a></li></ul></ul></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>home</a></li><hr><li><a href=https://berkselvi.dev/>english</a></li><li><a href=https://berkselvi.dev/tr/>türkçe</a></li></ul></nav></header><div class=content><div class=post><h4>Translations;</h4><a href=/tr/posts/correlationid-tracing-net-microservices-with-http-and-rabbitmq/>HTTP ve MassTransit ile .NET Mikroservislerinde CorrelationId Takibi</a><h1 class=post-title><a href=https://berkselvi.dev/posts/correlationid-tracing-net-microservices-with-http-and-rabbitmq/>CorrelationId Tracing in .NET Microservices with HTTP and MassTransit</a></h1><div class=post-meta><span class=post-date>July 14, 2024
</span><span class=post-author>:: Berk Selvi</span>
<span class=post-reading-time>:: 8 min read (1688 words)</span></div><div class=post-content><div><p>CorrelationId has a very important place under the title of Distributed Tracing in order to be able to trace the ongoing process during the communication between applications running distributed in the microservice architecture and to understand which steps came to this point if there is a performance-related or flow problem in a service.</p><p>CorrelationId must be carried throughout the entire lifecycle of a request, ensuring the correlation between different services. In this article, we will examine how to navigate the CorrelationId value using HTTP and RabbitMQ requests in a .NET based microservice architecture. This solution was designed to be a clear answer to our problem, but it is open to any comments and improvements, if you have a better solution in mind, please contact me.</p><img src=/img/correlationid-tracing-net-microservices-with-http-and-rabbitmq/big-picture.png alt="Big picture" loading=lazy><p class=image-sub-title>Big picture</p><p>We will manipulate the CorrelationId value between services by manipulating the header values ​​by intervening in incoming and outgoing requests with Middleware and Filter structures during communication between services using HTTP and MassTransit. During this travel between services, we will use the LogContext class provided by Serilog to log the contexts initiated by incoming requests with the given CorrelationId value. You can access all examples from the repo below.</p><p><a href=https://github.com/berkslv/lecture-correlation-id-microservices>GitHub - berkslv/lecture-correlation-id-microservices</a></p><p>We can use our Correlation class, which we could define as Scoped, to send the CorrelationId value we receive in incoming requests to our service in outgoing requests. However, in this way, our state value, which we move between classes with Dependency Injection methods, becomes inaccessible in a special case in our request that proceeds asynchronously: Since our <code>CorrelationHeaderHandler</code> class, which will intervene in the requests we make with the HttpClient using the DelegatingHandler class, will work in a separate DI scope from our application, the value of our Correlation class, which we could define as Scoped, becomes inaccessible in a this special case. This issue is also explained in Microsoft&rsquo;s own documentation as follows:</p><blockquote><p>When IHttpClientFactory creates a new delegating handler, it uses DI to fulfill the handler&rsquo;s constructor parameters. IHttpClientFactory creates a separate DI scope for each handler, which can lead to surprising behavior when a handler consumes a scoped service.</p></blockquote><p>As a solution to this problem, we will create a class called <code>AsyncStorage</code> and use the <code>AsyncLocal</code> class provided by Microsoft to create a structure that we can access at any time within the same thread in our async request to set the CorrelationId value:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> Order.API.Filters.Correlation;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// Stores and retrieves values in an async context.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;typeparam name=&#34;T&#34;&gt;What should be stored&lt;/typeparam&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AsyncStorage</span>&lt;T&gt; <span style=color:#66d9ef>where</span> T : <span style=color:#66d9ef>new</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> AsyncLocal&lt;T&gt; _asyncLocal = <span style=color:#66d9ef>new</span> AsyncLocal&lt;T&gt;();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> T Store(T val)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _asyncLocal.Value = val;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> _asyncLocal.Value;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> T? Retrieve()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> _asyncLocal.Value;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We will define the Correlation class, which we will provide as a type to the AsyncStorage class, as shown below. The Id property will contain the CorrelationId value.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> Order.API.Filters.Correlation;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// It holds the CorrelationId value that comes with HTTP requests and events handled via MassTransit.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Correlation</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Guid Id { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>init</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since we are storing the CorrelationId value in a location that is accessible throughout the request, let&rsquo;s now intercept incoming requests and extract the CorrelationId value from the headers. In microservice architecture, applications communicate between services not only via HTTP but also through event-based methods. However, in such initiated requests, we will carry the CorrelationId value in the headers provided by MassTransit, not in the HTTP headers.</p><img src=/img/correlationid-tracing-net-microservices-with-http-and-rabbitmq/filters-for-correlationid.png alt="Filters for CorrelationId" loading=lazy><p class=image-sub-title>Filters for CorrelationId</p><h1 id=correlationmiddleware>CorrelationMiddleware<a href=#correlationmiddleware class=hanchor arialabel=Anchor>&#8983;</a></h1><p>We define our CorrelationMiddleware class, which will intercept incoming HTTP requests and get the value from the CorrelationId HTTP header, as follows. If there is a value in the header, we first enrich it by putting this value as a separate field in the <code>LogContext</code> class provided by Serilog. Then, we store the CorrelationId value by giving the Correlation class to our <code>AsyncStorage</code> class. In this way, we will be able to get the CorrelationId value in incoming requests and use this value in outgoing requests.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> Order.API.Filters.Correlation;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// When the Http request is made, it takes the CorrelationId value from the HttpContext Header and sets the Correlation.Id value.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CorrelationMiddleware</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> RequestDelegate _next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> CorrelationMiddleware(RequestDelegate next)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _next = next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task InvokeAsync(HttpContext context, Correlation correlation)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> correlationIdHeader = context.Request.Headers[<span style=color:#e6db74>&#34;CorrelationId&#34;</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (!<span style=color:#66d9ef>string</span>.IsNullOrWhiteSpace(correlationIdHeader))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> correlationId = Guid.Parse(correlationIdHeader.ToString());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            LogContext.PushProperty(<span style=color:#e6db74>&#34;CorrelationId&#34;</span>, <span style=color:#66d9ef>new</span> ScalarValue(correlationId));
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            AsyncStorage&lt;Correlation&gt;.Store(<span style=color:#66d9ef>new</span> Correlation
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Id = correlationId
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> _next(context);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To add this middleware to our application, we edit Program.cs as follows.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> builder = WebApplication.CreateBuilder(args);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> app = builder.Build();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app.UseMiddleware&lt;CorrelationMiddleware&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app.Run();
</span></span></code></pre></div><h1 id=correlationconsumefilter>CorrelationConsumeFilter<a href=#correlationconsumefilter class=hanchor arialabel=Anchor>&#8983;</a></h1><p>If the request coming to our service is not HTTP, but a request triggered by an event, there will not be an HTTP header. For this reason, we define our CorrelationConsumeFilter class as follows to get the CorrelationId value from the header values ​​provided by MassTransit. In this class, before consuming the classes signed with IConsumer, we intercept the incoming events and get the CorrelationId value and add it to <code>LogContext</code> and <code>AsyncStorage&lt;Correlation></code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> Order.API.Filters.Correlation;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// It is triggered when there is an event consumed by MassTransit and sets the CorrelationId value to the Correlation class.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CorrelationConsumeFilter</span>&lt;T&gt; : IFilter&lt;ConsumeContext&lt;T&gt;&gt; <span style=color:#66d9ef>where</span> T : <span style=color:#66d9ef>class</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Task Send(ConsumeContext&lt;T&gt; context, IPipe&lt;ConsumeContext&lt;T&gt;&gt; next)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> correlationIdHeader = context.CorrelationId;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (correlationIdHeader.HasValue)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> correlationId = correlationIdHeader.Value;
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            LogContext.PushProperty(<span style=color:#e6db74>&#34;CorrelationId&#34;</span>, <span style=color:#66d9ef>new</span> ScalarValue(correlationId));
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            AsyncStorage&lt;Correlation&gt;.Store(<span style=color:#66d9ef>new</span> Correlation
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Id = correlationId
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> next.Send(context);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Probe(ProbeContext context)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s examine what we can do to add the Correlation value, which we store in <code>AsyncStorage&lt;Correlation></code>, to the relevant header fields in the event requests.</p><h1 id=correlationpublishfilter>CorrelationPublishFilter<a href=#correlationpublishfilter class=hanchor arialabel=Anchor>&#8983;</a></h1><p>We define our <code>CorrelationPublishFilter</code> class, which will intercept events published with MassTransit&rsquo;s <code>IPublishEndpoint</code>, as follows. This class intercepts published events, retrieves the CorrelationId value from <code>AsyncStorage&lt;Correlation></code>, and adds it to MassTransit&rsquo;s CorrelationId header.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> Order.API.Filters.Correlation;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// Sets the CorrelationId value of events published via MassTransit.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CorrelationPublishFilter</span>&lt;T&gt; : IFilter&lt;PublishContext&lt;T&gt;&gt; <span style=color:#66d9ef>where</span> T : <span style=color:#66d9ef>class</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Task Send(PublishContext&lt;T&gt; context, IPipe&lt;PublishContext&lt;T&gt;&gt; next)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> correlation = AsyncStorage&lt;Correlation&gt;.Retrieve();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (correlation <span style=color:#66d9ef>is</span> not <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            context.CorrelationId = Guid.Parse(correlation.Id.ToString()!);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> next.Send(context);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Probe(ProbeContext context)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=correlationsendfilter>CorrelationSendFilter<a href=#correlationsendfilter class=hanchor arialabel=Anchor>&#8983;</a></h1><p>If the event sent to MassTransit is not published and is sent using <code>IRequestClient&lt;T></code> with the request/response pattern, our <code>CorrelationSendFilter</code> class will intervene, not <code>CorrelationPublishFilter</code>. In this class, we intervene in the sent events, get the CorrelationId value from <code>AsyncStorage&lt;Correlation></code> and add it to the CorrelationId header value of MassTransit.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> Order.API.Filters.Correlation;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// Sets the CorrelationId value of events sent via MassTransit.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CorrelationSendFilter</span>&lt;T&gt; : IFilter&lt;SendContext&lt;T&gt;&gt; <span style=color:#66d9ef>where</span> T : <span style=color:#66d9ef>class</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Task Send(SendContext&lt;T&gt; context, IPipe&lt;SendContext&lt;T&gt;&gt; next)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> correlation = AsyncStorage&lt;Correlation&gt;.Retrieve();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (correlation <span style=color:#66d9ef>is</span> not <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            context.CorrelationId = Guid.Parse(correlation.Id.ToString());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> next.Send(context);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Probe(ProbeContext context)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To add our <code>CorrelationConsumeFilter</code>, <code>CorrelationPublishFilter</code> and <code>CorrelationSendFilter</code> classes to our application, we define our ConfigureServices class as follows and use this method in Program.cs.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConfigureServices</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> WebApplicationBuilder AddMassTransit(<span style=color:#66d9ef>this</span> WebApplicationBuilder builder, IConfiguration configuration)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> messageBroker = builder.Configuration.GetSection(<span style=color:#e6db74>&#34;MessageBroker&#34;</span>);
</span></span><span style=display:flex><span>        builder.Services.AddMassTransit(cfg =&gt;
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            cfg.SetKebabCaseEndpointNameFormatter();
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            cfg.AddConsumers(Assembly.GetExecutingAssembly());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cfg.UsingRabbitMq((context, config) =&gt;
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                config.UseSendFilter(<span style=color:#66d9ef>typeof</span>(CorrelationSendFilter&lt;&gt;), context);
</span></span><span style=display:flex><span>                config.UsePublishFilter(<span style=color:#66d9ef>typeof</span>(CorrelationPublishFilter&lt;&gt;), context);
</span></span><span style=display:flex><span>                config.UseConsumeFilter(<span style=color:#66d9ef>typeof</span>(CorrelationConsumeFilter&lt;&gt;), context);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                config.Host(messageBroker[<span style=color:#e6db74>&#34;Host&#34;</span>], messageBroker[<span style=color:#e6db74>&#34;VirtualHost&#34;</span>], h =&gt;
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    h.Username(messageBroker[<span style=color:#e6db74>&#34;Username&#34;</span>]!);
</span></span><span style=display:flex><span>                    h.Password(messageBroker[<span style=color:#e6db74>&#34;Password&#34;</span>]!);
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                config.ConfigureEndpoints(context);
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> builder;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> builder = WebApplication.CreateBuilder(args);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>builder.AddMassTransit(builder.Configuration);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> app = builder.Build();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app.Run();
</span></span></code></pre></div><h1 id=correlationheaderhandler>CorrelationHeaderHandler<a href=#correlationheaderhandler class=hanchor arialabel=Anchor>&#8983;</a></h1><p>If the request made from our service is an HTTP request, not an event, we define our <code>CorrelationHeaderHandler</code> class, which will intervene in the requests we make from our HttpClient class, which we will create with <code>IHttpClientFactory</code>, as follows. In this class, we intervene in HTTP requests made from our application, get the CorrelationId value from <code>AsyncStorage&lt;Correlation></code> and add it as a HTTP header.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// Middleware to be used in requests made with HttpClient. Adds the CorrelationId header to the requests made.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CorrelationHeaderHandler</span> : DelegatingHandler
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>async</span> Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> correlation = AsyncStorage&lt;Correlation&gt;.Retrieve();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (correlation <span style=color:#66d9ef>is</span> not <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            request.Headers.Add(<span style=color:#e6db74>&#34;CorrelationId&#34;</span>, correlation.Id.ToString());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>base</span>.SendAsync(request, cancellationToken);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To add this middleware to our application, we define Named Http Client in Progam.cs as follows and add the middleware that will intervene in requests made with <code>AddHttpMessageHandler</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> builder = WebApplication.CreateBuilder(args);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>builder.Services.AddTransient&lt;CorrelationHeaderHandler&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>builder.Services.AddHttpClient(<span style=color:#e6db74>&#34;Inventory&#34;</span>, c =&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        c.BaseAddress = <span style=color:#66d9ef>new</span> Uri(<span style=color:#e6db74>&#34;http://localhost:5053&#34;</span>);
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    .AddHttpMessageHandler&lt;CorrelationHeaderHandler&gt;();;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> app = builder.Build();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app.Run();
</span></span></code></pre></div><p>We use the Named Http Client we created as follows. If the requests we make here are not asynchronous, the middleware cannot intervene.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InventoryService</span> : IInventoryService
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IHttpClientFactory _httpClientFactory;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> InventoryService(IHttpClientFactory httpClientFactory)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _httpClientFactory = httpClientFactory;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task RemoveStockAsync(<span style=color:#66d9ef>string</span> productId, <span style=color:#66d9ef>int</span> quantity)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> httpClient = _httpClientFactory.CreateClient(<span style=color:#e6db74>&#34;Inventory&#34;</span>);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> response = <span style=color:#66d9ef>await</span> httpClient.PostAsync(<span style=color:#e6db74>$&#34;remove-stock/{productId}/{quantity}&#34;</span>, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        response.EnsureSuccessStatusCode();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this article, we explored how to effectively use CorrelationId to enhance distributed traceability in a .NET microservice architecture using HTTP and RabbitMQ. By leveraging Middleware and Filter structures, we were able to manipulate header values and propagate the CorrelationId across different services, ensuring comprehensive logging and monitoring with Serilog&rsquo;s LogContext framework.</p><p>We demonstrated how to handle CorrelationId in both HTTP requests and event-driven communication facilitated by MassTransit. By implementing <code>CorrelationMiddleware</code> and <code>CorrelationHeaderHandler</code> for HTTP; <code>CorrelationConsumeFilter</code>, <code>CorrelationPublishFilter</code>, and <code>CorrelationSendFilter</code> for event-driven communication. We ensured that the CorrelationId is consistently carried through the entire lifecycle of a request, providing a clear trace of the process flow and helping to identify performance or flow issues.</p><p>The use of <code>AsyncStorage&lt;Correlation></code> with the <code>AsyncLocal</code> class provided a reliable way to store and retrieve the CorrelationId value across different scopes, addressing challenges related to Dependency Injection and asynchronous processing.</p><p>I hope this guide helps you implement a robust distributed tracing solution in your own microservice architecture. For more detailed examples, you can check out the complete code repository on GitHub:</p><p><a href=https://github.com/berkslv/lecture-correlation-id-microservices>GitHub - berkslv/lecture-correlation-id-microservices</a></p><h1 id=resources>Resources<a href=#resources class=hanchor arialabel=Anchor>&#8983;</a></h1><p>The source I used for the correct use of the AsyncLocal class:</p><p><a href=https://medium.com/@mbearz/how-to-log-everything-using-middleware-and-httpclient-handler-42b8f628fe84>https://medium.com/@mbearz/how-to-log-everything-using-middleware-and-httpclient-handler-42b8f628fe84</a></p><hr><h2 id=conclusion>Conclusion<a href=#conclusion class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Thank you for reading! 🎉 In order not to miss my research in the field of software development, you can follow me at <a href=https://x.com/berkslv>@berkslv</a>.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://berkselvi.dev/posts/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/><span class=button__icon>←</span>
<span class=button__text>Event-Driven Architecture: Do you need other service’s data in microservice architecture</span>
</a></span><span class="button next"><a href=https://berkselvi.dev/posts/api-gateway-alternatives-from-a-net-developer-standpoint/><span class=button__text>API Gateway Alternatives from a .NET Developer's Perspective: YARP, Ocelot, Kong, APISIX, and KrakenD</span>
<span class=button__icon>→</span></a></span></div></div><script src=https://utteranc.es/client.js repo=berkslv/berkselvi.dev issue-term=title theme=dark-blue crossorigin=anonymous async></script></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Made by Berk Selvi.<br>This site is <a href=https://github.com/berkslv/berkselvi.dev target=_blank>open source</a></span></div></div></footer><script src=https://berkselvi.dev/assets/main.js></script><script src=https://berkselvi.dev/assets/prism.js></script><script src=https://berkselvi.dev/assets/languageSelector.js></script></div></body></html>