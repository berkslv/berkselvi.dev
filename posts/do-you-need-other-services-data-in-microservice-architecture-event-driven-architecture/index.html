<!doctype html><html lang=en><head><title>Event-Driven Architecture: Do you need other service’s data in microservice architecture :: Berk Selvi | Software Developer</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="In microservice architecture, data dependency between services can be managed with synchronous or asynchronous communication. Synchronous communication can cause scalability and accessibility issues due to tight service coupling, while asynchronous communication reduces dependency, allowing services to operate independently. Choosing the right method depends on the specific scenario, but asynchronous communication generally provides more scalable and accessible solutions."><meta name=keywords content="microservices,event,service to service comminication,synchronous communication,asynchronous communication"><meta name=robots content="noodp"><link rel=canonical href=https://berkselvi.dev/posts/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/><link rel=stylesheet href=https://berkselvi.dev/assets/style.css><link rel=stylesheet href=https://berkselvi.dev/assets/green.css><link rel=canonical href=https://berkselvi.dev/posts/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/><link rel=apple-touch-icon sizes=57x57 href=/icon/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/icon/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/icon/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/icon/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/icon/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/icon/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/icon/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/icon/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/icon/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/icon/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/icon/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/icon/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/icon/favicon-16x16.png><link rel=manifest href=/icon/manifest.json><meta name=msapplication-TileColor content="#1D1E28"><meta name=msapplication-TileImage content="/icon/ms-icon-144x144.png"><meta name=theme-color content="#1D1E28"><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="berkslv"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Event-Driven Architecture: Do you need other service’s data in microservice architecture"><meta property="og:description" content="In microservice architecture, data dependency between services can be managed with synchronous or asynchronous communication. Synchronous communication can cause scalability and accessibility issues due to tight service coupling, while asynchronous communication reduces dependency, allowing services to operate independently. Choosing the right method depends on the specific scenario, but asynchronous communication generally provides more scalable and accessible solutions."><meta property="og:url" content="https://berkselvi.dev/posts/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/"><meta property="og:site_name" content="Berk Selvi | Software Developer"><meta property="og:image" content="https://berkselvi.dev/img/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/cover.jpg"><meta property="twitter:image" content="https://berkselvi.dev/img/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/cover.jpg"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2024-09-07 00:00:00 +0300 +0300"><script async src="https://www.googletagmanager.com/gtag/js?id=G-W0L24EMSQ5"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W0L24EMSQ5")</script><link href=https://berkselvi.dev/css/custom.css rel=stylesheet></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=menu-trigger><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu"><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/></svg></div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>home</a></li><div class=spacer></div><ul class=language-selector><ul class=language-selector-current><li>english ▾</li></ul><ul class="language-selector__more hidden"><li><a href=https://berkselvi.dev/>english</a></li><li><a href=https://berkselvi.dev/tr/>türkçe</a></li></ul></ul></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>home</a></li><hr><li><a href=https://berkselvi.dev/>english</a></li><li><a href=https://berkselvi.dev/tr/>türkçe</a></li></ul></nav></header><div class=content><div class=post><h4>For turkish version;</h4><a href=/tr/posts/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/>Event-Driven Architecture: Mikroservis mimarisinde başka servislerin verilerine mi ihtiyacınız var</a><h1 class=post-title><a href=https://berkselvi.dev/posts/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/>Event-Driven Architecture: Do you need other service’s data in microservice architecture</a></h1><div class=post-meta><span class=post-date>September 7, 2024
</span><span class=post-author>:: Berk Selvi</span>
<span class=post-reading-time>:: 9 min read (1872 words)</span></div><div class=post-content><div><p>In applications developed with microservice architecture, domains are generally tried to be strictly separated from each other. In the example we will examine, all logic and data related to the product are located in the product service, while the organization service that manages the sales consultants who can create orders with this product also hosts its own logic and data.</p><p>However, the <code>createUnit()</code> request we will make to create a sales consultant in the organization service will need the data of the product service for validation reasons. Shouldn&rsquo;t the unit be given the permission to create a product that doesn&rsquo;t exist? In this case, the organization service will need the data of the product service, which is not in its domain and is not under its responsibility.</p><p>We can access this data either synchronously or asynchronously. First, we’ll look at accessing it synchronously and the problems we may encounter, then we’ll address the potential issues with using the asynchronous method. Let’s begin.</p><h2 id=synchronous-communication>Synchronous communication<a href=#synchronous-communication class=hanchor arialabel=Anchor>&#8983;</a></h2><p>With the request we will send to our organization service via REST, we will trigger the <code>createUnit()</code> method and create a unit. However, since this service will need product data for validation purposes, it will need to retrieve this data synchronously through an HTTP REST <code>getProduct()</code> request.</p><p>During runtime, for the <code>createUnit()</code> method to be processed, both the organization service and the product service need to be up and accessible, and there must be no issues with the network connection between them. If the product service is not operational, the organization service will also not function. Even when both services are up and accessible, if the product service is slow, the synchronous request flow will be blocked, causing the organization service to slow down as well. To overcome this issue, the organization service will need to scale during periods of high demand. However, since the product service has a runtime dependency, it will also need to be scaled in the same way to handle the large number of requests coming from the organization. If we apply this practice to all services, all services will need to scale together. As a result, the organization service will be highly dependent on the product service, and they will have to continue operating together rather than independently. If all the services in our microservice architecture become dependent on each other in this way, the inaccessibility of a single service could lead to all other services becoming inaccessible as well.</p><p>During design time, if a change is made to the <code>getProduct()</code> API in the product service, the developers of the organization service would also need to update their HTTP client integrations accordingly. This change would likely require modifying the organization service&rsquo;s codebase as well.</p><p>In conclusion, since coupling will occur both at runtime and design time, the two services will be tightly coupled, leading to what Jonathan Tower calls a <a href="https://www.youtube.com/watch?v=p2GlRToY5HI&t=1203s">distributed monolith</a>. Any change in one service will directly affect the other, making it difficult to quickly respond to constantly changing business requirements. Any improvements made to the <code>getProduct()</code> method in the product service would also need to be implemented by the other services that consume it. After completing these updates, all services connected synchronously must be accessible for end-users to use the application.</p><img src=/img/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/synchronous-communication.png alt="Synchronous communication" loading=lazy><p class=image-sub-title>Synchronous communication</p><p>In a scenario where we want to guarantee an SLA to our customer, if we optimistically offer a 99.5% uptime guarantee for both the product and organization services, we are accepting that there could be up to 43 hours of downtime annually. In a scenario where the product and organization services are dependent on each other during runtime, using the calculation $0.995 * 0.995 = 0.990$, the dependency created by synchronous communication results in our services offering twice the downtime guarantee, potentially leading to 87 hours of downtime annually.</p><table><thead><tr><th style=text-align:left></th><th style=text-align:left>Product</th><th style=text-align:left>Organization</th><th style=text-align:left>Product & Organization</th></tr></thead><tbody><tr><td style=text-align:left>Uptime percentage</td><td style=text-align:left>99.5</td><td style=text-align:left>99.5</td><td style=text-align:left>99.0</td></tr><tr><td style=text-align:left>Month</td><td style=text-align:left>716</td><td style=text-align:left>716</td><td style=text-align:left>712</td></tr><tr><td style=text-align:left>Downtime in month</td><td style=text-align:left>4</td><td style=text-align:left>4</td><td style=text-align:left>7</td></tr><tr><td style=text-align:left>Year</td><td style=text-align:left>8716</td><td style=text-align:left>8716</td><td style=text-align:left>8672</td></tr><tr><td style=text-align:left>Downtime in year</td><td style=text-align:left>43</td><td style=text-align:left>43</td><td style=text-align:left>87</td></tr></tbody></table><p>So, how do we avoid this method, which can cause so many headaches? Let&rsquo;s look at another solution for communication between services.</p><h2 id=asynchronous-communication>Asynchronous communication<a href=#asynchronous-communication class=hanchor arialabel=Anchor>&#8983;</a></h2><p>If we don’t want to choose synchronous communication, which increases inter-service dependency in every possible direction, we can proceed with the alternative: asynchronous communication. By reversing the arrows with this method, the product service publishes a domain event called <code>ProductCreatedEvent</code> whenever there is an update in the product table. All services listening to this event update their own local <code>products</code> tables.</p><p>When the organization service needs product data, it reads from its own <code>products</code> table. This table is unaffected by the organization&rsquo;s workflows and is only read from. This way, in the <code>createUnit()</code> method, we query the product data from the same database where we save the unit data.</p><img src=/img/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/asynchronous-communication.png alt="Asynchronous communication" loading=lazy><p class=image-sub-title>Asynchronous communication</p><p>With this method, we access the product data from the organization&rsquo;s database in the <code>createUnit()</code> flow, eliminating runtime dependency on the product service.</p><p>By eliminating runtime dependency, we stop making synchronous queries to the product service’s <code>getProduct()</code> endpoint. At design time, the dependency we faced while developing is also removed. After making a change in the <code>getProduct()</code> method of the product service, the team managing the organization service no longer needs to make any changes.</p><p>During design time, we only have an asynchronous dependency, and we only need to make changes when necessary. If a new column is added to the product domain model, it can be added directly to the event as a new field. If a column is removed from the product table, it can be sent with default values without being removed from the event type and marked as obsolete. Services can respond to these added or removed columns as needed or continue without making any changes.</p><p>The product service does not need to care about who is processing the published event. Anyone who needs this data can consume the event, maintain their own copy of the product data, and carry on their work without having to synchronize communication with the product service. This leads to more scalable and accessible applications since they can now operate independently without depending on other services.</p><p>If we worry that our tables will mix domains, we can keep tables from different domains in a separate database schema as shown in the example below.</p><img src=/img/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/asynchronous-communication-2.png alt="Asynchronous communication 2" loading=lazy><p class=image-sub-title>Asynchronous communication 2</p><h2 id=eventual-consistency>Eventual consistency<a href=#eventual-consistency class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The biggest issue that may arise from this method is eventual consistency. The update of the relevant table in the organization service may not reflect at the exact same moment a product is added to the product service. Depending on the availability of the message broker, there could be a delay of a few milliseconds or seconds.</p><p>We can also explain this situation with CAP theory. If we keep the Partition tolerance leg, which is one of the 3 legs of CAP theory, constant, one of the Consistency and Availability legs will increase while the other will decrease. Therefore, we will not be able to provide these three options at the same time. Here, we need to decide according to the workflow we are working with.</p><p>For example, in an e-commerce system, the &ldquo;add to cart&rdquo; feature might need to be highly available. If the &ldquo;add to cart&rdquo; feature isn’t working, receiving an error message like “please try again later” might cause customers to switch to a competitor&rsquo;s site. However, if we see 2 instead of 1 of the same item in our cart, we can simply adjust our cart and continue the payment process.</p><p>However, the same approach may not work for hotel reservations. In contrast to the cart example, consistency is probably more critical. Returning an error message like &ldquo;please try again later&rdquo; is much more logical than renting out the same room to multiple customers.</p><p>In conclusion, synchronous communication is suitable for workflows that need immediate consistency, while asynchronous communication is better for workflows that require high availability. Typically, in microservice architecture, high availability is preferred, as synchronous communication tightly couples all services together.</p><img src=/img/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/high-avalability-vs-immidiate-consistency.png alt="High availability vs Immediate consistency" loading=lazy><p class=image-sub-title>High availability vs Immediate consistency</p><h2 id=edge-cases-in-asynchronous-communication>Edge cases in asynchronous communication<a href=#edge-cases-in-asynchronous-communication class=hanchor arialabel=Anchor>&#8983;</a></h2><p>If you have decided to proceed with event-driven architecture in the communication between your services, you will need to do something to ensure data consistency in the system. If a create request comes to one of our services and we publish CreatedEvent, we first update the database and then publish the event, if the transaction we execute in the database results in an error, and we publish the event without following it, or if the transaction we execute in the database results in success but the event bus cannot be accessed afterwards, the data that is distributed in our applications may fall into an inconsistent state. In order to prevent this situation, while the product service updates the product data in its own database, it also adds the relevant event to the outbox table in the same database, and then a different thread continuously scans this table and publishes the new events. Since the record we make to the database will be processed atomically, it is guaranteed that the event data will be created in the outbox table while the product data is being created. However, in an application that works as multiple instances, situations such as an event reading from the same outbox table twice and publishing it twice may be encountered. In this case, the idempotency problem already arises.</p><p>If the result of a method being called once is the same as the result of multiple calls, then this is an idempotent method. In order to prevent an event from being processed multiple times due to different reasons and thus disrupting data consistency in the system, we will need to save the unique message id values ​​of the events to the database after they are consumed, and continue processing if the message id value is not in the database when a new event is to be consumed. Chris Richardson (microservices.io) also touches on this issue in his article Pattern: <a href=https://microservices.io/patterns/communication-style/idempotent-consumer.html>Idempotent Consumer</a>.</p><img src=/img/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/without-outbox-idempotency.png alt="Without Outbox & Idempotency" loading=lazy><p class=image-sub-title>Without Outbox & Idempotency</p><img src=/img/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/outbox-idempotency.png alt="Outbox & Idempotency" loading=lazy><p class=image-sub-title>Outbox & Idempotency</p><p>As a result, as with most solutions to problems in the field of Computer Science, we do not have a silver bullet. After considering the advantages and disadvantages of both methods in detail and in the domain we are working in, we can continue with the method we want. However, my suggestion would be to eliminate the dependency between services by using asynchronous communication whenever possible.</p><p>You can access the .NET project I developed to simulate situations that may occur while working with asynchronous and synchronous data communication from the github repo below. In the example, the infrastructure provided by MassTransit was used for the outbox structure, and no special development was made for this feature.</p><p><a href=https://github.com/berkslv/lecture-fetch-other-service-data-with-event-driven-architecture>GitHub - berkslv/lecture-fetch-other-service-data-with-event-driven-architecture</a></p><h2 id=resources>Resources<a href=#resources class=hanchor arialabel=Anchor>&#8983;</a></h2><p><a href="https://www.youtube.com/watch?v=p2GlRToY5HI&t=1203s">Don’t Build a Distributed Monolith - Jonathan &ldquo;J.&rdquo; Tower - NDC London 2023</a></p><p><a href="https://www.youtube.com/watch?v=STKCRSUsyP0">The Many Meanings of Event-Driven Architecture • Martin Fowler • GOTO 2017</a></p><p><a href="https://www.youtube.com/watch?v=AEbJgpamZ4w&t=898s">Solving distributed data problems in a microservice architecture | Microservices.io</a></p><p><a href="https://www.youtube.com/watch?v=rZxIzrjvSGg&t=716s">You Keep Using That Word • Sam Newman • GOTO 2023</a></p><p><a href=https://microservices.io/patterns/communication-style/idempotent-consumer.html>Microservices Pattern: Pattern: Idempotent Consumer</a></p><p><a href=https://www.reactivemanifesto.org/en>The Reactive Manifesto</a></p><h2 id=conclusion>Conclusion<a href=#conclusion class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Thank you for reading! 🎉 In order not to miss my research in the field of software development, you can follow me at <a href=https://x.com/berkslv>@berkslv</a>.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://berkselvi.dev/posts/correlationid-tracing-net-microservices-with-http-and-rabbitmq/><span class=button__text>CorrelationId Tracing in .NET Microservices with HTTP and MassTransit</span>
<span class=button__icon>→</span></a></span></div></div><script src=https://utteranc.es/client.js repo=berkslv/berkselvi.dev issue-term=title theme=dark-blue crossorigin=anonymous async></script></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Made by Berk Selvi</span></div></div></footer><script src=https://berkselvi.dev/assets/main.js></script><script src=https://berkselvi.dev/assets/prism.js></script><script src=https://berkselvi.dev/assets/languageSelector.js></script></div></body></html>