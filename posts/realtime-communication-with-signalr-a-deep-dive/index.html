<!doctype html><html lang=en><head><title>Real-Time Communication with SignalR: A Deep Dive :: Berk Selvi | Software Developer</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Discover the power of real-time communication with SignalR! In this blog post, learn how SignalR simplifies adding live features to your .NET applications by abstracting complex protocols like WebSockets, Server-Sent Events, and Long Polling. From setting up SignalR in your project to advanced features like targeting specific clients and scaling with Redis, this guide has everything you need to create responsive and dynamic applications. Let's dive into the world of SignalR!"><meta name=keywords content="signalr,websocket,.NET,long polling"><meta name=robots content="noodp"><link rel=canonical href=https://berkselvi.dev/posts/realtime-communication-with-signalr-a-deep-dive/><link rel=stylesheet href=https://berkselvi.dev/assets/style.css><link rel=stylesheet href=https://berkselvi.dev/assets/green.css><link rel=canonical href=https://berkselvi.dev/posts/realtime-communication-with-signalr-a-deep-dive/><link rel=apple-touch-icon sizes=57x57 href=/icon/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/icon/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/icon/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/icon/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/icon/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/icon/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/icon/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/icon/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/icon/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/icon/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/icon/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/icon/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/icon/favicon-16x16.png><link rel=manifest href=/icon/manifest.json><meta name=msapplication-TileColor content="#1D1E28"><meta name=msapplication-TileImage content="/icon/ms-icon-144x144.png"><meta name=theme-color content="#1D1E28"><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="berkslv"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Real-Time Communication with SignalR: A Deep Dive"><meta property="og:description" content="Discover the power of real-time communication with SignalR! In this blog post, learn how SignalR simplifies adding live features to your .NET applications by abstracting complex protocols like WebSockets, Server-Sent Events, and Long Polling. From setting up SignalR in your project to advanced features like targeting specific clients and scaling with Redis, this guide has everything you need to create responsive and dynamic applications. Let's dive into the world of SignalR!"><meta property="og:url" content="https://berkselvi.dev/posts/realtime-communication-with-signalr-a-deep-dive/"><meta property="og:site_name" content="Berk Selvi | Software Developer"><meta property="og:image" content="https://berkselvi.dev/img/realtime-communication-with-signalr-a-deep-dive/cover.webp"><meta property="twitter:image" content="https://berkselvi.dev/img/realtime-communication-with-signalr-a-deep-dive/cover.webp"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2024-11-29 00:00:00 +0300 +0300"><script async src="https://www.googletagmanager.com/gtag/js?id=G-W0L24EMSQ5"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W0L24EMSQ5")</script><link href=https://berkselvi.dev/css/custom.css rel=stylesheet></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=menu-trigger><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu"><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/></svg></div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>home</a></li><div class=spacer></div><ul class=language-selector><ul class=language-selector-current><li>english ▾</li></ul><ul class="language-selector__more hidden"><li><a href=https://berkselvi.dev/>english</a></li><li><a href=https://berkselvi.dev/tr/>türkçe</a></li></ul></ul></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>home</a></li><hr><li><a href=https://berkselvi.dev/>english</a></li><li><a href=https://berkselvi.dev/tr/>türkçe</a></li></ul></nav></header><div class=content><div class=post><h4>Translations;</h4><a href=/tr/posts/realtime-communication-with-signalr-a-deep-dive/>SignalR ile Gerçek Zamanlı İletişim: Derinlemesine İnceleme</a><h1 class=post-title><a href=https://berkselvi.dev/posts/realtime-communication-with-signalr-a-deep-dive/>Real-Time Communication with SignalR: A Deep Dive</a></h1><div class=post-meta><span class=post-date>November 29, 2024
</span><span class=post-author>:: Berk Selvi</span>
<span class=post-reading-time>:: 9 min read (1835 words)</span></div><div class=post-content><div><p>In today&rsquo;s world where data is moving very quickly, real-time communication is a must for modern applications to give users smooth experiences. SignalR is an essential library when you want to create .NET application that communicates in real-time with others. When using SignalR, all communication and network requirements are abstracted by the library and you only need to call the method like in the RPC. By leveraging SignalR, you can easily create live dashboards, chat applications, or simple notification features that many web applications need. Let’s get started.</p><h2 id=why-signalr>Why SignalR?<a href=#why-signalr class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Traditional models of client-server communication revolve around the request-response model, which is considered less efficient and limited for high interaction needs, and requires the client to making a request when data is needed. SignalR is designed to eliminate these challenges by keeping the same connection alive from the client to the server.</p><h3 id=key-advantages-of-signalr>Key Advantages of SignalR:<a href=#key-advantages-of-signalr class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li><strong>Real-Time Communication:</strong> Clients receive the updates as soon as possible without necessarily making new requests.</li><li><strong>Cross-Platform Support:</strong> SignalR now has a full range of functionality independent of any platform and browsers.</li><li><strong>Abstraction of Complex Protocols:</strong> SignalR has the ability to use WebSocket, Server-Sent Events and Long Polling protocols, which provide a better relationship between the client and the server and allow them to choose the most efficient protocol. If the WebSocket protocol is not available by the client, SignalR tries to use other methods by selecting them according to its internal algorithm. (<a href=https://learn.microsoft.com/en-us/aspnet/signalr/overview/getting-started/introduction-to-signalr#transport-selection-process>https://learn.microsoft.com/en-us/aspnet/signalr/overview/getting-started/introduction-to-signalr#transport-selection-process</a>)</li><li><strong>Integration with .NET apps:</strong> Effective incorporation of .NET successfully guarantees the smooth through incorporation to modern .NET applications.</li></ul><h3 id=getting-started-with-signalr>Getting Started with SignalR<a href=#getting-started-with-signalr class=hanchor arialabel=Anchor>&#8983;</a></h3><p>To implement SignalR in your .NET project, you can follow these steps:</p><h3 id=1-signalr-nuget-package>1. SignalR NuGet Package<a href=#1-signalr-nuget-package class=hanchor arialabel=Anchor>&#8983;</a></h3><p>SignalR comes with .NET system libraries therefore you don’t need to install any additional packages. However if Visual Studio goes crazy you may want to try install the <code>Microsoft.AspNetCore.SignalR</code> package.</p><h3 id=2-create-a-hub-class>2. Create a Hub Class<a href=#2-create-a-hub-class class=hanchor arialabel=Anchor>&#8983;</a></h3><p>The Hub acts as the central component that manages connections and sends messages to clients. You can compare this class to Controllers where you accept HTTP requests, except here we can accept requests or make a request directly to the client. Here’s a simple example, clients invoke <code>SendNotification(string content)</code> method to make a call to server and server send a message to all or specific clients with <code>Clients.All.SendAsync("ReceiveNotification", content)</code> method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Microsoft.AspNetCore.SignalR;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NotificationsHub</span> : Hub
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task SendNotification(<span style=color:#66d9ef>string</span> content)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> Clients.All.SendAsync(<span style=color:#e6db74>&#34;ReceiveNotification&#34;</span>, content);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-configure-the-hub-in-programcs>3. Configure the Hub in <code>Program.cs</code><a href=#3-configure-the-hub-in-programcs class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Just register SignalR services and map the hub endpoint as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> builder = WebApplication.CreateBuilder(args);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>builder.Services.AddSignalR();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> app = builder.Build();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app.MapHub&lt;NotificationsHub&gt;(<span style=color:#e6db74>&#34;hubs/notification&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app.Run();
</span></span></code></pre></div><h3 id=4-signalr-client>4. SignalR Client<a href=#4-signalr-client class=hanchor arialabel=Anchor>&#8983;</a></h3><p>SignalR supports various client platforms, including Javascript, .NET, and Java. If you don’t want to implement SignalR library in that platforms, you can simply use Postman to test your endpoint. But you must insert <strong>0x1E</strong> character at the end of the json. This is a requirement of the SignalR internal protocol. If you use Javascript library to implement SignalR you don’t need to deal with this kind of details.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;protocol&#34;</span>: <span style=color:#e6db74>&#34;json&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;version&#34;</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>After specifying the protocol, you can send and receive message from SignalR Hub as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;arguments&#34;</span> : [<span style=color:#e6db74>&#34;hello world&#34;</span>],
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;target&#34;</span> : <span style=color:#e6db74>&#34;SendNotification&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;type&#34;</span> : <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here is a quick demo:</p><img src=/img/realtime-communication-with-signalr-a-deep-dive/postman-signalr-demo.gif alt="SignalR and Postman demo" loading=lazy><p class=image-sub-title>SignalR and Postman demo</p><h2 id=advanced-features>Advanced Features<a href=#advanced-features class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=1-strongly-typed-hubs>1. Strongly Typed Hubs<a href=#1-strongly-typed-hubs class=hanchor arialabel=Anchor>&#8983;</a></h3><p>For better maintainability, use strongly typed hubs to specify interface of the hub:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>INotificationsClient</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Task ReceiveNotification(<span style=color:#66d9ef>string</span> content);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NotificationsHub</span> : Hub&lt;INotificationsClient&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task SendNotification(<span style=color:#66d9ef>string</span> content)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> Clients.All.ReceiveNotification(content);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-targeting-specific-clients>2. Targeting Specific Clients<a href=#2-targeting-specific-clients class=hanchor arialabel=Anchor>&#8983;</a></h3><p>SignalR enables sending messages to specific users or groups. You can use this feature to send notification to only related ones, just add user to group using their userId or groupName, then send a notification to this userId:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>await</span> Clients.User(userId).ReceiveNotification(<span style=color:#e6db74>&#34;Hello, User!&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>await</span> Clients.Group(groupName).ReceiveNotification(<span style=color:#e6db74>&#34;Hello, Group!&#34;</span>);
</span></span></code></pre></div><p>If you want to target specific clients with SignalR using userId, you have to implement <code>IUserIdProvider</code> that coming from SignalR package like that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserIdProvider</span> : IUserIdProvider
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> GetUserId(HubConnectionContext connection)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> connection.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Program.cs</span>
</span></span><span style=display:flex><span>services.AddSingleton&lt;IUserIdProvider, CustomUserIdProvider&gt;();
</span></span></code></pre></div><h3 id=3-using-ihubcontext-to-access-the-hub-from-outside-the-hub>3. Using <code>IHubContext</code> to access the hub from outside the hub<a href=#3-using-ihubcontext-to-access-the-hub-from-outside-the-hub class=hanchor arialabel=Anchor>&#8983;</a></h3><p>You can send message to clients in outside of the hub as follows. Just Inject the IHubContext of type, and send a message to them.</p><p>You can trigger the hub when some event is occured in your system with this greate feature. For example, when a long running batch job is completed you can notify your users about the result.</p><p>Just a quick note, your code can be much cleaner if you abstract this IHubContext interface with another interface like <code>INotificationDispatcher</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NotificationDispatcher</span>(IHubContext&lt;NotificationsHub&gt; hubContext) : INotificationDispatcher
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task SendNotification(<span style=color:#66d9ef>string</span> content)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> hubContext.Clients.All.SendAsync(<span style=color:#e6db74>&#34;ReceiveNotification&#34;</span>, content);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task SendNotificationToUser(<span style=color:#66d9ef>string</span> userId, <span style=color:#66d9ef>string</span> content)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> hubContext.Clients.User(userId).SendAsync(<span style=color:#e6db74>&#34;ReceiveNotification&#34;</span>, content);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task SendNotificationToGroup(<span style=color:#66d9ef>string</span> groupName, <span style=color:#66d9ef>string</span> content)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> hubContext.Clients.Group(groupName).SendAsync(<span style=color:#e6db74>&#34;ReceiveNotification&#34;</span>, content);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-securing-signalr>4. Securing SignalR<a href=#4-securing-signalr class=hanchor arialabel=Anchor>&#8983;</a></h3><p>By default, SignalR hubs can be accessed by any client. To restrict access, use the classic <code>[Authorize]</code> attribute. Ensure that users authenticate using mechanisms like JWT, which SignalR leverages to identify connected users:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[Authorize]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NotificationsHub</span> : Hub
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Hub methods</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=5-scaling-signalr-with-redis-backplane>5. Scaling SignalR with Redis backplane<a href=#5-scaling-signalr-with-redis-backplane class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Scaling SignalR across multiple servers ensures reliable real-time communication for high-demand applications that running in multiple instances. A <strong>Redis backplane</strong> synchronizes messages between SignalR servers, ensuring clients connected to different servers receive messages seamlessly. Here is a quote from microsoft docs:</p><blockquote><p>The SignalR Redis backplane uses the pub/sub feature to forward messages to other servers. When a client makes a connection, the connection information is passed to the backplane. When a server wants to send a message to all clients, it sends to the backplane. The backplane knows all connected clients and which servers they&rsquo;re on. It sends the message to all clients via their respective servers.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>dotnet add package Microsoft.AspNetCore.SignalR.StackExchangeRedis
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Program.cs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>builder.Services.AddSignalR()
</span></span><span style=display:flex><span>    .AddStackExchangeRedis(<span style=color:#e6db74>&#34;localhost:6379&#34;</span>, options =&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        options.Configuration.ChannelPrefix = <span style=color:#e6db74>&#34;SignalR&#34;</span>;
</span></span><span style=display:flex><span>    });
</span></span></code></pre></div><p>If you don’t belive me, you can try to run your signalr app in more than one instance in the local testing enviroment with docker compose:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>signalr</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>your-app</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;5000:5000&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>depends_on</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>redis</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>redis:latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;6379:6379&#34;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>docker-compose up --scale signalr<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>
</span></span></code></pre></div><h2 id=signalr-communication-models>SignalR Communication Models<a href=#signalr-communication-models class=hanchor arialabel=Anchor>&#8983;</a></h2><p>SignalR abstracts multiple transport methods to ensure compatibility and performance:</p><h3 id=websocket-websockets><strong>WebSocket (</strong><code>webSockets</code><strong>)</strong>:<a href=#websocket-websockets class=hanchor arialabel=Anchor>&#8983;</a></h3><p>WebSockets is the most efficient and preferred transport for real-time, bi-directional communication in SignalR. It establishes a persistent, full-duplex connection over a single TCP channel, allowing simultaneous message exchange between the client and server. This makes it ideal for applications that require low-latency, high-throughput interactions, such as live chats, collaborative editing tools, online gaming, and financial tickers.</p><p>WebSockets transitions to its own lightweight protocol (<code>ws://</code> or <code>wss://</code>) after an initial HTTP handshake, reducing the overhead associated with traditional HTTP-based communication. However, scaling WebSockets requires specialized infrastructure, such as WebSocket-aware load balancers and sticky sessions, to maintain connection affinity. SignalR simplifies these complexities, managing connection persistence, automatic reconnections, and fallback to alternative protocols when WebSockets are unavailable.</p><h3 id=server-sent-events-serversentevents><strong>Server-Sent Events (</strong><code>serverSentEvents</code><strong>):</strong><a href=#server-sent-events-serversentevents class=hanchor arialabel=Anchor>&#8983;</a></h3><p>SSE provides a lightweight, HTTP-based mechanism for one-way communication, where the server streams real-time updates to the client over a long-lived connection. It uses the standardized EventSource API and transmits data formatted as <code>text/event-stream</code>. This makes SSE simple to implement and efficient for use cases like live dashboards, notifications, and news feeds, where only server-to-client communication is needed.</p><p>Because it operates over standard HTTP, SSE integrates easily with existing HTTP infrastructure and does not require specialized proxies or load balancers, making it easier to scale compared to WebSockets. However, it lacks support for Internet Explorer and does not natively allow client-to-server communication, which must be handled through separate HTTP requests. SignalR automatically leverages SSE when WebSockets is unavailable, providing a seamless fallback for environments with restricted capabilities.</p><h3 id=long-polling-longpolling><strong>Long Polling (</strong><code>longPolling</code><strong>):</strong><a href=#long-polling-longpolling class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Long Polling emulates real-time communication by continuously opening and closing HTTP connections. The client sends a request to the server and keeps it open until the server has data to send. Once the data is delivered, the client immediately establishes a new request. This approach minimizes latency between updates and creates the appearance of a push-based connection.</p><p>While Long Polling works with all browsers and is easy to implement, it incurs more overhead due to frequent HTTP requests and responses. It is less efficient compared to persistent connections like WebSockets or SSE, especially for high-frequency updates. In SignalR, Long Polling serves as a fallback when neither WebSockets nor SSE is supported, ensuring compatibility across legacy systems and restricted environments.</p><h3 id=forever-frame-foreverframe><strong>Forever Frame (</strong><code>foreverFrame</code><strong>):</strong><a href=#forever-frame-foreverframe class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Forever Frame is a legacy protocol specific to older versions of Internet Explorer, designed to enable real-time, one-way communication. It operates by embedding a hidden iframe in the client’s browser that maintains an open connection to the server. The server continuously streams executable scripts to the iframe, which are executed by the client to process incoming data.</p><p>While functional for its time, Forever Frame has significant limitations, including high overhead and lack of bi-directional communication. Any client-to-server interaction requires separate standard HTTP requests, making it less efficient and cumbersome to implement. SignalR includes Forever Frame for backward compatibility but uses it only as a last-resort fallback in environments restricted to legacy Internet Explorer browsers.</p><h3 id=websockets-vs-server-sent-events>Websockets vs Server-Sent Events<a href=#websockets-vs-server-sent-events class=hanchor arialabel=Anchor>&#8983;</a></h3><p>WebSockets and Server-Sent Events (SSE) cater to different real-time communication needs. <strong>WebSockets</strong> enable full-duplex, low-latency communication, ideal for chat, gaming, and collaborative tools. In contrast, <strong>SSE</strong> provides lightweight, one-way updates, perfect for live dashboards or notifications.</p><p>WebSockets use a custom protocol (<code>ws://</code> or <code>wss://</code>) for efficient two-way messaging but require WebSocket-aware infrastructure for scaling. SSE operates over standard HTTP (<code>text/event-stream</code>), making it easier to scale with traditional HTTP tools, though it only supports server-to-client communication and lacks Internet Explorer support.</p><p>SignalR abstracts these differences, automatically prioritizing WebSockets for performance and falling back to SSE or other methods to ensure seamless real-time functionality across varied environments.</p><h2 id=specifiying-the-protocol>Specifiying the protocol<a href=#specifiying-the-protocol class=hanchor arialabel=Anchor>&#8983;</a></h2><p>SignalR allows you to explicitly specify the transport protocol to be used for real-time communication. By default, SignalR automatically selects the best available transport with its internal algorithm, but you can customize this behavior based on your application&rsquo;s needs.</p><p>You can choose WebSockets for its efficiency and fall back to Long Polling when WebSockets are unavailable with that code in Program.cs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>
</span></span><span style=display:flex><span>app.MapHub&lt;NotificationsHub&gt;(<span style=color:#e6db74>&#34;/hubs/notification&#34;</span>, opt =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    opt.Transports = HttpTransportType.WebSockets | HttpTransportType.LongPolling;
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>Or in the client side with JavaScript:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>connection</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>signalR</span>.<span style=color:#a6e22e>HubConnectionBuilder</span>()
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>withUrl</span>(<span style=color:#e6db74>&#34;/hubs/notification&#34;</span>, { 
</span></span><span style=display:flex><span>	    <span style=color:#a6e22e>transport</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>signalR</span>.<span style=color:#a6e22e>HttpTransportType</span>.<span style=color:#a6e22e>WebSockets</span> 
</span></span><span style=display:flex><span>		    <span style=color:#f92672>|</span> <span style=color:#a6e22e>signalR</span>.<span style=color:#a6e22e>HttpTransportType</span>.<span style=color:#a6e22e>LongPolling</span> })
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>build</span>();
</span></span></code></pre></div><h2 id=summary>Summary<a href=#summary class=hanchor arialabel=Anchor>&#8983;</a></h2><p>SignalR makes adding real-time features to .NET applications simple and efficient. It abstracts complex networking protocols, letting you focus on building live dashboards, chat apps, or notifications without worrying about the underlying transport. With support for WebSockets, Server-Sent Events (SSE), and Long Polling, SignalR automatically picks the best protocol for your environment.</p><p>If you want to access the source code, you can find the whole project on my GitHub account:</p><p><a href=https://github.com/berkslv/lecture-signalr-deep-dive>GitHub - berkslv/lecture-signalr-deep-dive</a></p><hr><h2 id=conclusion>Conclusion<a href=#conclusion class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Thank you for reading! 🎉 In order not to miss my research in the field of software development, you can follow me at <a href=https://x.com/berkslv>@berkslv</a>.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://berkselvi.dev/posts/do-you-need-other-services-data-in-microservice-architecture-event-driven-architecture/><span class=button__text>Event-Driven Architecture: Do you need other service’s data in microservice architecture</span>
<span class=button__icon>→</span></a></span></div></div><script src=https://utteranc.es/client.js repo=berkslv/berkselvi.dev issue-term=title theme=dark-blue crossorigin=anonymous async></script></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Made by Berk Selvi.<br>This site is <a href=https://github.com/berkslv/berkselvi.dev target=_blank>open source</a></span></div></div></footer><script src=https://berkselvi.dev/assets/main.js></script><script src=https://berkselvi.dev/assets/prism.js></script><script src=https://berkselvi.dev/assets/languageSelector.js></script></div></body></html>